<?xml version="1.0" encoding="UTF-8" ?>
<Document corpusVersion="3" name="A27_F07_Highly_Adaptive_Liquid_Simulations__on_Tetrahedral_Meshes">
  
    1bc32fd79f71ddaed6dc90f472a41b0eaae0eba6d03053a8819e16a4b2305917
    3x6m
    http://dx.doi.org/10.1145/2461912.2461982
  
  
    
      
        <article-title>Highly Adaptive Liquid Simulations on Tetrahedral Meshes</article-title>
      
      
        
          Ryoichi Ando ∗ Nils Thürey † Kyushu University ScanlineVFX
          ∗
        
      
      ∗ E-mail: and@verygood.aid.design.kyushu-u.ac.jp † E-mail: nils.thuerey@scanlinevfx.com ‡ E-mail: wojtan@ist.ac.at
      
        
        Figure 1: Our adaptive simulation framework allows us to efficiently simulate highly detailed splashes on large open surfaces. In this case, maximum BCC mesh resolutions from 8 to 1024 cells were used, leading to strong horizontal grading along the surface.
      
      <DRI_Challenge_Goal ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Challenge_Goal" ann3="DRI_Challenge_Goal">We introduce a new method for efficiently simulating liquid with extreme amounts of spatial adaptivity.</DRI_Challenge_Goal> <Sentence agreement="All_Equal">Our method combines several key components to drastically speed up the simulation of largescale fluid phenomena: We leverage an alternative Eulerian tetrahedral mesh discretization to significantly reduce the complexity of the pressure solve while increasing the robustness with respect to element quality and removing the possibility of locking.</Sentence> <DRI_Approach agreement="All_Equal">Next, we enable subtle free-surface phenomena by deriving novel second-order boundary conditions consistent with our discretization.</DRI_Approach> <DRI_Approach agreement="All_Equal">We couple this discretization with a spatially adaptive Fluid-Implicit Particle (FLIP) method, enabling efficient, robust, minimally-dissipative simulations that can undergo sharp changes in spatial resolution while minimizing artifacts.</DRI_Approach> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Along the way, we provide a new method for generating a smooth and detailed surface from a set of particles with variable sizes.</DRI_Outcome> <DRI_Challenge_Goal ann2="DRI_Approach" agreement="3diff" ann1="DRI_Challenge_Goal" ann3="DRI_Outcome_Contribution">Finally, we explore several new sizing functions for determining spatially adaptive simulation resolutions, and we show how to couple them to our simulator.</DRI_Challenge_Goal> <DRI_Approach ann2="DRI_Outcome" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome_Contribution">We combine each of these elements to produce a simulation algorithm that is capable of creating animations at high maximum resolutions while avoiding common pitfalls like inaccurate boundary conditions and inefficient computation.</DRI_Approach>
	  <h2>I.3.7 [Computer Graphics]: </h2>Three-Dimensional Graphics and Realism—Animation; I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling—Physically based modeling <h2>Keywords:</h2> motion editing, motion signal-processing, spacetime constraints, motion capture.	  
	  
      
        
          Chris Wojtan ‡ IST Austria
        
      
      Links:
      
        
      
      <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">DL PDF</Sentence>
      
        
      
    
    
      
        <h1>1 Introduction</h1>
      
      <DRI_Challenge_Goal agreement="All_Equal">This paper aims to produce fluid simulations with a high degree of spatial adaptivity.</DRI_Challenge_Goal> <DRI_Challenge_Goal agreement="All_Equal">We desire to enable a simulator to focus its computational resources on the visually interesting regions of a fluid flow, while remaining computationally efficient and avoiding common artifacts due to a spatially adaptive pressure solve.</DRI_Challenge_Goal> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Previous approaches have made great strides towards this goal, but they often exhibit visual artifacts, a lack of computational robustness, or an unacceptably hefty computational expense.</DRI_Background> <DRI_Background agreement="All_Equal">The groundbreaking work of Losasso et al. [2004] introduced an octree for spatial adaptivity, but it suffers from spurious flows at T-junctions.</DRI_Background> <DRI_Background agreement="All_Equal">Finite volume methods [Batty et al. 2010] repair these spatial artifacts at the expense of solving a significantly larger system of equations and sacrificing computational stability near poorly-shaped elements.</DRI_Background> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">Furthermore, many existing methods still are not truly spatially adaptive in the sense that their computational complexity is still tied to a uniform grid or spatial parameter.</DRI_Challenge> <DRI_Outcome_Contribution ann2="DRI_Approach" agreement="3diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome">We introduce a combination of techniques that successfully makes adaptive fluid simulation practical at large scales.</DRI_Outcome_Contribution> <DRI_Approach agreement="All_Equal">We first reduce memory and computational costs by switching from a finite volume method to a discretization with a significantly smaller linear system for the pressure solve, which has the side effect of increasing the simulator’s robustness to poor-quality elements and effectively preventing locking artifacts.</DRI_Approach> <DRI_Approach agreement="All_Equal">We next derive second-order Dirichlet boundary conditions consistent with our discretization to benefit from the subtle surface dynamics associated with an accurate pressure solve.</DRI_Approach> <DRI_Approach agreement="All_Equal">We combine this robust and efficient tetrahedral meshbased fluid simulator with a spatially adaptive method for sampling particles for FLIP-based velocity advection, giving us a method free from any single spatial resolution.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Approach">In addition to our adaptive FLIP simulator, we also introduce a new method for computing a surface from a distribution of particles with variable radii.</DRI_Approach> <DRI_Outcome agreement="All_Equal">We found that this method out-performs previous methods in cases of extreme spatial adaptivity by exhibiting smoother surfaces without sacrificing detail.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Our fluid simulator works well with spatially adaptive tetrahedral meshes, but it is another question to decide exactly how these adaptive meshes should be generated.</DRI_Outcome> <DRI_Approach agreement="All_Equal">We investigate various methods for generating these adaptive meshes by experimenting with several sizing functions, allowing us to precisely dictate where simulation detail should occur.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">Some examples are a surface curvature-based metric that adds detail only where needed on the fluid surface, a turbulence metric that adds detail only where interesting fluid motion occurs, and a visibility metric that adds detail only in front of a virtual camera.</DRI_Approach> <DRI_Outcome_Contribution ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">Concretely, the contributions of our work are: • a novel tetrahedral discretization of the pressure projection step that is efficient to solve and robust to poor-quality elements; • an accurate treatment of second-order boundary conditions within the tetrahedral mesh; • a new technique for extracting a smooth surface from particles with varying radii; • and the inclusion of a flexible sizing function to focus computational resources on important areas of the flow with minimal overhead.</DRI_Outcome_Contribution> <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">These contributions work together to produce a practical fluid simulator that exhibits low computational and memory complexity, fewer visual artifacts, and a high effective simulation resolution.</DRI_Outcome_Contribution>
      
        <h1>2 Related Work</h1>
        <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">Our work is based on the Fluid-Implicit Particle (FLIP) method introduced to the computer graphics community by Zhu and Bridson [2005], which arguably represents the state-of the art for detailed and robust liquid simulations.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">The algorithm still follows the general ideas of the Stable Fluid solver [Stam 1999], and can be readily combined with second-order treatment of free surface boundary conditions [Enright et al. 2003].</DRI_Approach> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">FLIP derives its success from the fact that it uses particles to compute an accurate, nondiffusive transport of flow quantities, in combination with a gridbased solve to accurately enforce constraints for mass conservation.</DRI_Background> <DRI_Background agreement="All_Equal">The FLIP algorithm is heavily used in the special effects industry, and recent advances have introduced accurate coupling with obstacles [Batty et al. 2007], highly viscous materials [Batty and Bridson 2008], and two-phase flows [Boyd and Bridson 2012].</DRI_Background> <DRI_Background agreement="All_Equal">Traditionally, Cartesian grids are very popular for fluid simulations.</DRI_Background> <DRI_Background agreement="All_Equal">The Marker-And-Cell (MAC) approach [Harlow and Welch 1965], which stores velocity components at cell faces and pressure samples at cell centers, results in discretizations with good properties in terms of stability and accuracy.</DRI_Background> <DRI_Background agreement="All_Equal">An inherent difficulty is that simulations on regular grids become prohibitively expensive for large resolutions.</DRI_Background> <DRI_Background agreement="All_Equal">Thus, many works have proposed methods to focus the computations on regions that are of particular interest.</DRI_Background> <DRI_Background agreement="All_Equal">One example are octrees, which were used by Losasso et al. [2004; 2005] to refine the computational grid in a controllable way.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">This approach, however, suffers from numerical diffusion and an inconsistent discretization near the tree’s T-junctions.</DRI_Background> <DRI_Background agreement="All_Equal">Targeting a similar direction as our work, Hong et al. [2009] and Ando et al. [2012] have demonstrated methods to adapt the resolution of FLIP particles in a simulation.</DRI_Background> <DRI_Background agreement="All_Equal">Both methods, in contrast to ours, focus on static computational grids and are restricted to smaller differences in particle size.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Although Cartesian grids are widely used, they are limited in their flexibility to adapt to a simulation setup.</DRI_Background> <DRI_Background agreement="All_Equal">Because of this, tetrahedral grids are popular for methods targeting adaptivity.</DRI_Background> <DRI_Background agreement="All_Equal">In combination with a suitable method to discretize the problem at hand, they allow for very flexible computational grids.</DRI_Background> <DRI_Background agreement="All_Equal">One example is the work of Klingner et al. [Klingner et al. 2006] which demonstrated the use of a Stable Fluids based solver for tetrahedral grids conforming to object boundaries.</DRI_Background> <DRI_Background agreement="All_Equal">Another example is the non-linear fluid solver developed by Mullen et al. [2009], which leads to an energy conserving solve.</DRI_Background> <DRI_Approach ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">Unlike these methods, we make use of a non-conforming grid with Body-Centered Cubic (BCC) lattices.</DRI_Approach> <DRI_Background agreement="All_Equal">These meshes were also used by Chentanez et al. [2007] and by Batty et al. [2010] for liquid simulations.</DRI_Background> <DRI_Approach agreement="All_Equal">We will denote this class of algorithms as Finite Volume Methods (FVM).</DRI_Approach> <DRI_Approach ann2="DRI_Background" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Unspecified">These methods are primarily suitable for uniformly sampled particles, and we will demonstrate in Section 7 that their placement of pressure samples at tetrahedral circumcenters leads to numerical problems in combination with graded BCC meshes.</DRI_Approach> <DRI_Background agreement="All_Equal">Another direction of research performs fluid simulations based on arbitrary elements.</DRI_Background> <DRI_Background agreement="All_Equal">Clausen et al. [2013] and Misztal et al. [2010] have proposed a method to simulate liquids with a computational grid conforming to a triangulation of a liquid surface.</DRI_Background> <DRI_Background agreement="All_Equal">Both methods lead to an increased computational cost in comparison to the more efficient tetrahedral BCC meshes.</DRI_Background> <DRI_Background agreement="All_Equal">Sin et al. [2009] proposed an alternative method for hybrid Lagrangian-Eulerian solvers which combines a Voronoi-based pressure solver and particles.</DRI_Background> <DRI_Background agreement="All_Equal">Using this Vornoi-based approach for tetrahedral meshes would yield a pressure matrix similar to ours.</DRI_Background> <DRI_Background agreement="All_Equal">Like our method, Brochu et al. [2010] used this discretization in combination with embedded second-order boundary conditions.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">Both of these approaches discretize velocities with per-face flux values, while we store velocity vectors at cell barycenters.</DRI_Background> <DRI_Background agreement="All_Equal">Adaptive simulations have also been explored in the context of SPH simulations without Eulerian grids.</DRI_Background> <DRI_Background agreement="All_Equal">The work of [Adams et al. 2007] shares similarities with our approach, as it is able to simulate a wider range of particle radii, and it proposes a surface reconstruction method in the adaptive setting.</DRI_Background> <DRI_Outcome ann2="DRI_Approach" agreement="3diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">We will show in Section 5 that our surface creation method results in surfaces with fewer visual artifacts.</DRI_Outcome> <DRI_Background agreement="All_Equal">Additionally, a robust and efficient method for adaptive SPH simulations was introduced by Solenthaler et al. [2011], but this work primarily targets the coupling of two different particle resolutions.</DRI_Background> <DRI_Background agreement="All_Equal">Several other methods have been proposed to reconstruct smooth surfaces around collections of particles without orientation.</DRI_Background> <DRI_Background agreement="All_Equal">One approach that is commonly used is to compute a signed distance function with averaged particle radii and centroids [Zhu and Bridson 2005].</DRI_Background> <DRI_Background agreement="All_Equal">A variant of this approach, taking into account information about the spatial variance of the particle’s neighborhood was proposed by Yu et al. [2010].</DRI_Background> <DRI_Background agreement="All_Equal">Both methods primarily target particles with constant radius.</DRI_Background> <DRI_Background agreement="All_Equal">More recently, a level-set based method was proposed that computes a constrained optimization with bihar- monic smoothing [Bhattacharya et al. 2011].</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="3diff" ann1="DRI_Background" ann3="DRI_Approach">However, such an optimization would be complicated to apply in our unstructured setting.</DRI_Background> <DRI_Approach agreement="All_Equal">In contrast to these methods, our approach for surface creation computes the union of convex hulls around triplets of particles, which leads to a smooth and closed surface around a collection of arbitrarily sized particles.</DRI_Approach>
      
      
        <h1>3 Fluid Solver</h1>
        <DRI_Challenge_Goal agreement="All_Equal">The aim of our method is to solve the Navier-Stokes equations, which for incompressible, Newtonian, inviscid flows can be written as ρDu/Dt = − p + f , with the additional constraint · u = 0 to enforce a divergence-free velocity field.</DRI_Challenge_Goal> <DRI_Approach agreement="All_Equal">Here, u, p and f denote velocity, pressure and external forces, respectively, while D/Dt denotes the material derivative.</DRI_Approach> <DRI_Approach agreement="All_Equal">The density ρ is constant in our case.</DRI_Approach> <DRI_Approach agreement="All_Equal">We solve these equations using operator splitting [Stam 1999], and a level set φ(x) = 0 defines the position of the liquid-gas interface.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">Spatial Discretization An inherent strength of the FLIP algorithm is its hybrid nature.</Sentence> <DRI_Approach agreement="All_Equal">The motion of the fluid is computed in a Lagrangian manner using particles, while the pressure projection step is computed on an Eulerian grid.</DRI_Approach> <DRI_Approach agreement="All_Equal">We will now describe how we compute the pressure projection using a tetrahedral discretization.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">This projection of the velocities into a divergence-free state can be formulated as the Poisson problem</Sentence>
        
          1
          ∆t 2 p = · u ∗ , ρ
        
        <Sentence agreement="All_Equal">where u ∗ denotes an intermediate velocity after the advection.</Sentence> <DRI_Approach agreement="All_Equal">In the following, however, we prefer an alternate view that looks at this problem from an energy minimization perspective: we want to compute the minimal change in kinetic energy necessary to reach a divergence-free state of the flow similar to [Batty et al. 2007].</DRI_Approach> <Sentence ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="Sentence">This can be formulated as:</Sentence>
        
          2
          p = arg min 1 ||u ∗ − ∆t p|| 2 ρdV p Ω 2 ρ
        
        <DRI_Approach agreement="All_Equal">Here, Ω represents the domain of the computational grid, and we choose to discretize this space using tetrahedral cells.</DRI_Approach> <DRI_Approach agreement="All_Equal">This has the advantage of giving us a natural way to handle cells of different size, while yielding a consistent discretization of the differential operators involved.</DRI_Approach> <DRI_Approach agreement="All_Equal">We store pressure samples at the nodes of the tetrahedral mesh, while velocities are stored at cell centers.</DRI_Approach> <DRI_Unspecified ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">This configuration is illustrated in Figure 2 .</DRI_Unspecified> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Note that by assuming a piece-wise constant velocity and a linear change of pressure within a cell, this setup results in a constant pressure gradient per tetrahedron, by construction.</DRI_Approach> <DRI_Approach agreement="All_Equal">In the following, we denote the number of cells with m and the number of nodes with n, and we indicate discretized quantities with caret notation.</DRI_Approach> <Sentence agreement="All_Equal">Based on this representation we can discretize Eq.</Sentence> <Sentence agreement="All_Equal">(2) with</Sentence>
        
          3
          m p = arg min 1 || u ˆ i ∗ − ∆t [ ] p|| 2 ρV i , p ˆ 2 ρ i
        
        <Sentence agreement="All_Equal">where we denote the volume of a cell with V i and the discretized gradient operator with [ ].</Sentence> <DRI_Approach agreement="All_Equal">It consists of a m×n matrix, computing a per-tetrahedron gradient from nodal values.</DRI_Approach> <DRI_Approach agreement="All_Equal">Consequently, we define the divergence operator to be the transpose of the discretized gradient.</DRI_Approach> <DRI_Approach agreement="All_Equal">Before we go ahead to define [ ], we want to outline the rest of the steps for our pressure solve.</DRI_Approach> <Sentence agreement="All_Equal">We solve equation Eq.</Sentence> <Sentence agreement="All_Equal">(3) with the commonly used least squares technique, yielding</Sentence>
        
          4
          ∆t T T ∗ [ ] V [ ] p = [ ] V u ˆ , ρ
        
        
          
          
          
          Figure 2:
        
        <DRI_Unspecified agreement="All_Equal">Our discretization compared to previous approaches: the MAC grid stores velocity components normal to faces and pressure values at the center.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">The FVM discretizations follow along these lines and store velocities normal to faces and pressure values at the circumcenter of a cell.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">In our approach we store a 3component velocity vector at the barycenter of a cell and pressure values at each node.</DRI_Unspecified>
        <Sentence agreement="All_Equal">where V denotes a matrix containing the V i as diagonal entries.</Sentence> <DRI_Approach agreement="All_Equal">The [ ] T [ ] matrix-matrix multiplication results in a square n × n matrix, which is symmetric and positive definite.</DRI_Approach> <Sentence agreement="All_Equal">In the following, we will denote the matrix on the left hand side of Eq.</Sentence> <Sentence agreement="All_Equal">(4) as A. Given appropriate boundary conditions, we can use standard tools, such as a commonly used pre-conditioned conjugate gradient solver to compute a solution (we use the one suggested in [Bridson 2008]).</Sentence> <Sentence agreement="All_Equal">Now, all that is left to construct the left-hand side matrix and the right-hand side terms for Eq.</Sentence> <Sentence agreement="All_Equal">(4) is to define [ ].</Sentence> <DRI_Approach agreement="All_Equal">As we assume a linear change of the pressure for each cell, we can use simple barycentric interpolation to retrieve the pressure p at a position inside a cell.</DRI_Approach> <Sentence agreement="All_Equal">Given the nodal pressure values p 1..</Sentence><Sentence agreement="All_Equal">4 and barycentric weights σ 1..</Sentence><Sentence agreement="All_Equal">4 this means p = σ 1 p 1 + σ 2 p 2 + σ 3 p 3 + σ 4 p 4 .</Sentence> <DRI_Approach agreement="All_Equal">In line with finite element methods using linear elements, we define the gradient based on the partial derivatives of the barycentric interpolation.</DRI_Approach> <Sentence agreement="All_Equal">E.g.</Sentence><Sentence agreement="All_Equal">, the first component of the gradient for a cell is computed with</Sentence>
        
          5
          ∂ ∂σ 1 ∂σ 2 ∂σ 3 ∂σ 4 p = p 1 + p 2 + p 3 + p 4 . ∂x ∂x ∂x ∂x ∂x
        
        <Sentence agreement="All_Equal">To set up the final linear system of Eq.</Sentence> <Sentence agreement="All_Equal">(4) for the pressure solve, we loop over all tetrahedra to compute the derivatives of the barycentric interpolation, adding their contributions to the global matrix.</Sentence> <DRI_Approach agreement="All_Equal">In contrast to previous work, our pressure solve is a linear system that has n degrees of freedom, n being the number of nodes in the tetrahedral mesh.</DRI_Approach> <DRI_Approach agreement="All_Equal">For our BCC mesh, n is in practice smaller than the number of tetrahedra m (by a factor of 6 on average).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">A direct implication of this smaller linear system is that it is faster to solve.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">A second, less obvious implication of the smaller linear system is that it effectively prevents artifacts known as locking.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">These artifacts are commonly observed in finite element methods for problems in elasticity.</DRI_Approach> <DRI_Background ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Different methods have been proposed to circumvent these problems, e.g., using linear elements for pressure instead of piece-wise constant ones [Irving et al. 2007].</DRI_Background> <DRI_Background ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Other works explicitly smooth the pressure field to reduce locking problems [Misztal et al. 2010].</DRI_Background> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">In general, locking can be observed if the pressure basis can represent more, and higher-frequency, functions than the basis for the velocity.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">Thus, choosing a more restrictive basis for pressure, as in [Irving et al. 2007], or explicitly removing high-frequency information from the pressure [Misztal et al. 2010], reduces the chance of locking.</DRI_Approach> <DRI_Approach agreement="All_Equal">Our method, by construction, has more degrees of freedom for representing velocity fields than pressure fields.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Although we cannot prove that a local configuration over-constraining the velocities will never occur, the larger number of degrees of freedom for our velocities effectively prevents locking artifacts, and we have not encountered any in our tests.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">Boundary Conditions Second-order boundary conditions are a central component for accurate and visually appealing simulations with non-conforming grids.</Sentence> <Sentence agreement="All_Equal">Achieving second-order accuracy for obstacle boundary conditions is straightforward with our discretization: we can rely on the formulation of previous work [Batty et al. 2007], and set the volume of a cell V i in Eq.</Sentence> <Sentence agreement="All_Equal">(4) to the volume that is filled with fluid.</Sentence> <DRI_Approach agreement="All_Equal">For the free surface, we have to ensure that the Dirichlet boundary condition p = 0 is satisfied at the interface position.</DRI_Approach> <DRI_Approach agreement="All_Equal">Usually, this means computing a pressure value for nodes outside of the liquid so that a linear interpolation along an edge of a cell gives zero at the correct position [Enright et al. 2005; Lew and Buscaglia 2008].</DRI_Approach> <DRI_Approach agreement="All_Equal">Considering two pressure samples along an edge, we’ll denote values inside the air with a G subscript, and values inside the liquid with an L subscript in the following.</DRI_Approach> <DRI_Approach agreement="All_Equal">For a Cartesian MAC grid, the ghost pressure value p G is given by p G = p L φ G /φ L .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">In our case, however, this approach does not yield the desired result.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The reason is that our velocity samples are not in line with the direct connections of the pressure samples – they are not locally orthogonal to each other.</DRI_Approach> <DRI_Approach agreement="All_Equal">Instead, we have to ensure the boundary conditions result in the correct pressure value at the cell center.</DRI_Approach> <DRI_Approach agreement="All_Equal">In the following we will show how to derive suitable free-surface boundary conditions to ensure second-order accuracy within our framework.</DRI_Approach> <Sentence agreement="All_Equal">In order to achieve accurate and smooth surface motions with our method, we compute the ghost pressure values p G with a linear combination of liquid pressure values as:</Sentence>
        
          6
          p G = w 1 p 1 + w 2 p 2 + w 3 p 3 ,
        
        <Sentence agreement="All_Equal">where w n and p n denote unknown coefficients and adjacent liquid pressures in the same tetrahedron.</Sentence> <DRI_Approach agreement="All_Equal">Note that for p i that are not inside of the liquid, we set w i = 0.</DRI_Approach> <DRI_Approach agreement="All_Equal">In line with the traditional ghost fluid method, we define p G uniquely for each tetrahedron.</DRI_Approach> <Sentence agreement="All_Equal">To handle the most general case, let’s suppose that p 1..</Sentence><Sentence agreement="All_Equal">3 are all liquid pressure values.</Sentence> <Sentence agreement="All_Equal">Once we have a value for p G , we can compute a pressure gradient for the tetrahedron and update the velocity at its center with:</Sentence>
        
          7
          u ˆ new = u ˆ ∗ − ∆t [ ] p G p 1 p 2 p 3 T ρ
        
        <DRI_Approach ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">In order to do this we need to compute the coefficients w n .</DRI_Approach> <Sentence agreement="All_Equal">p G can be rewritten in terms of a barycentric interpolation of the three values in the liquid as:</Sentence>
        
          8
          p G = p L φ G / φ  ̃ L
        
        <Sentence agreement="All_Equal">with φ  ̃ L = θ 1 φ 1 + θ 2 φ 2 + θ 3 φ 3 , and p L = θ 1 p 1 + θ 2 p 2 + θ 3 p 3 .</Sentence> <DRI_Approach agreement="All_Equal">Here the θ n are a set of barycentric coordinate coefficients such that θ 1 +θ 2 +θ 3 = 1, and a tilde superscript denotes a value interpolated with the barycentric weights.</DRI_Approach> <Sentence agreement="All_Equal">Substituting Eq.8 into Eq.6 yields</Sentence>
        
          9
          w n = θ n φ G / φ  ̃ L .
        
        <DRI_Approach agreement="All_Equal">That means the values w n are determined by those of the θ n coefficients, which we will compute in the following.</DRI_Approach> <DRI_Approach agreement="All_Equal">Note that, theoretically, θ n could take any values as long as they add up to one.</DRI_Approach> <Sentence agreement="All_Equal">Before embedding the boundary conditions, the matrix entries of the pressure solve for a single tetrahedron are, according to Eq.</Sentence> <Sentence agreement="All_Equal">(4), given by ∆t [ ] T V [ ]p = b.</Sentence> <DRI_Approach agreement="All_Equal">The computation of the ghost fluid ρ values is independent of the right-hand side b, so we will restrict the discussion to the left hand side.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">We denote the components of the local symmetric 4 × 4 matrix on the left hand side with:  λ 1 α β γ </Sentence>
        
          10
          α λ 2 a b    β a λ 3 c  γ b c λ 4
        
        <DRI_Approach ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">Assuming, without loss of generality, that the first vertex is the one outside of the liquid volume, we embed the boundary condition into
        M based on the w n coefficients.</DRI_Approach> <Sentence agreement="All_Equal">Then the first row of the system is changed to:</Sentence>
        
          11
           1 −w 1 −w 2 −w 3   p G   0  α λ 2 a b p 1 b 1     =   .  β a λ 3 c   p 2   b 2  γ b c λ 4 p 3 b 3
        
        <DRI_Approach agreement="All_Equal">We can extract two constraints for each θ n from this form, which, together with the barycentric coefficient constraint, give us a 3 × 3 matrix M that can be inverted analytically.</DRI_Approach> <Sentence agreement="All_Equal">A full derivation of these steps can be found in Appendix A. With this analytic expression we can compute the ghost pressure coefficients as:</Sentence>
        
          12
          φ G / φ  ̃ L  α  w = α + β + γ  β γ 
        
        <Sentence agreement="All_Equal">This boundary condition ensures second-order accuracy while maintaining symmetry when it is assembled into the matrix of Eq.</Sentence> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">(4).</Sentence> <DRI_Approach agreement="All_Equal">If the quality of a tetrahedron is good, 0 &lt; θ n &lt; 1 is guaranteed.</DRI_Approach> <DRI_Approach agreement="All_Equal">In this case, the resulting matrix is symmetric positivedefinite and can be easily inverted by the commonly used preconditioned conjugate gradient methods.</DRI_Approach> <DRI_Approach agreement="All_Equal">However, positive off-diagonal terms of the matrix can result in values of θ outside of the range [0, 1], leading to an indefinite linear system.</DRI_Approach> <DRI_Approach agreement="All_Equal">In these cases we consider the tetrahedron to have a poor quality.</DRI_Approach> <Sentence agreement="All_Equal">When using ghost fluid boundary conditions with a regular MAC grid, it is common practice to clamp small values in the denominator of Eq.</Sentence> <Sentence agreement="All_Equal">(9) to prevent ill-conditioned pressure matrices.</Sentence> <DRI_Approach agreement="All_Equal">Effectively, this means reverting to first-order accuracy when second-order accuracy is intractable.</DRI_Approach> <DRI_Approach agreement="All_Equal">We implement a similar step in our algorithm to overcome numerical problems resulting from badly shaped cells.</DRI_Approach> <DRI_Approach agreement="All_Equal">We check whether the ghost fluid boundary conditions would violate diagonal dominance of an equation in our linear system.</DRI_Approach> <DRI_Approach agreement="All_Equal">If we detect such a case, we smoothly transition to first order accuracy.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">Specifically, when we have computed M , we check if a resulting diagonal term M i,i is smaller than φλ 2..</Sentence><Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">4 .</Sentence> <DRI_Approach agreement="All_Equal">Here, φ denotes a tolerance factor that we set to φ = 0.25.</DRI_Approach> <Sentence agreement="All_Equal">Whenever we detect such a case, we compute a coefficient k with</Sentence>
        
          13
          φ − 1 φ − 1 φ − 1 k = min λ 2 , λ 3 , λ 4 , w 2 α w 3 β w 4 γ
        
        <Sentence agreement="All_Equal">and multiply each w n with k when embedding.</Sentence> <DRI_Approach agreement="All_Equal">Note that this scaling does not break the symmetry of the resulting linear system.</DRI_Approach> <DRI_Approach agreement="All_Equal">More specifically, for k = 1 this yields full second-order accuracy, while for badly shaped tetrahedra the resulting k = 0 means that we revert to the standard rounding strategy of a first order accurate method.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">With our BCC mesh, all regular BCC tetrahedra have very good quality and valid θ n values.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">The graded BCC tetrahedra, on the other hand, can be of lower quality and can require the use of Eq.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">(13).</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Luckily, in our tests these tetrahedra make up only a very small fraction of the mesh.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">Velocity Interpolation The FLIP advection step traces particles based on the velocities from the Eulerian grid.</Sentence> <DRI_Approach agreement="All_Equal">For this we need to construct a continuous velocity field based on the discrete values in our tetrahedral mesh.</DRI_Approach> <DRI_Approach agreement="All_Equal">As we store velocities at the cell centers, the interpolation would ideally use the dual mesh consisting of the Voronoi cells of each node [Brochu et al. 2010].</DRI_Approach> <DRI_Approach agreement="All_Equal">Unfortunately, performing interpolations within arbitrary Voronoi cells would be expensive and require a large amount of computation compared to the other steps of our simulator.</DRI_Approach> <DRI_Approach agreement="All_Equal">Instead, we have found the following approach to yield high speed and good accuracy: we first interpolate the centered velocities to the nodes, similar to [Chentanez et al. 2007].</DRI_Approach> <DRI_Approach agreement="All_Equal">Instead of interpolating these averaged values directly (which would result in smeared out motion), we temporarily subdivide the cells of our mesh by inserting a vertex at the center where we have an accurate velocity sample.</DRI_Approach> <DRI_Approach agreement="All_Equal">We then perform barycentric interpolation based on these subdivided cells, ensuring a C 0 continuous velocity that retains the original velocities at cell centers.</DRI_Approach> <DRI_Approach agreement="All_Equal">Note that these four smaller tetrahedra do not have to be stored explicitly.</DRI_Approach> <DRI_Approach agreement="All_Equal">We construct them on the fly when a sample is requested from one of the original cells.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">Manipulating FLIP particles The spacing between FLIP particles may drift over time, and high-frequency errors may contribute to a bumpy surface.</Sentence> <DRI_Approach agreement="All_Equal">We combat these problems by directly manipulating particle positions.</DRI_Approach> <DRI_Approach agreement="All_Equal">During each time step, we apply the position correction algorithm of Ando et al. [2012]; this algorithm essentially pushes each particle away from its neighbors to prevent clustering.</DRI_Approach> <DRI_Approach agreement="All_Equal">We also introduce two special behaviors when the particles are close to the liquid surface (less than a distance of six times the particle radius).</DRI_Approach> <DRI_Approach agreement="All_Equal">First, we impose the constraint that the position correction step may only move particles near the surface tangentially to the fluid interface.</DRI_Approach> <DRI_Approach agreement="All_Equal">Secondly, particles near the surface may leave gaps when they spread out quickly.</DRI_Approach> <DRI_Approach agreement="All_Equal">Our method naturally fills in these gaps by slightly pulling each particle towards the fluid interface.</DRI_Approach> <DRI_Approach agreement="All_Equal">For particles near the interface, this pulling force acts in addition to the position correction.</DRI_Approach> <DRI_Approach agreement="All_Equal">FLIP particles that partake in splashes and sprays can pose a significant burden on computational resources, especially in an adaptive framework like ours.</DRI_Approach> <DRI_Approach agreement="All_Equal">This inefficiency stems from the fact that water droplets undergo extremely simple ballistic motion.</DRI_Approach> <DRI_Approach agreement="All_Equal">Theoretically, we know that such a small region with purely free-surface boundary conditions will yield zero internal forces, so we simply detect individual FLIP particles that have no neighbors within six times their radius, remove them from the pressure solve, and accelerate them with gravity instead.</DRI_Approach> <DRI_Approach agreement="All_Equal">When these particles eventually enter the neighborhood of other particles at some point in the future, we resume treating them like fluid by returning them to the pressure solve.</DRI_Approach> <DRI_Approach agreement="All_Equal">This decision allows us to avoid aggressively refining the tetrahedral mesh in locations where the physical motion is uninteresting.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Only a small percentage of the particles are simulated in this way, e.g., 1.7% on average for Figure 6 .</DRI_Approach>
        
          
          Figure 3: A simple geometric setup creating a big splash inside a container. This simulation, with a maximum resolution of 256 cells, took 1.3 minutes per frame on average.
        
      
      
        <h1>4 Adaptivity</h1>
        <DRI_Approach agreement="All_Equal">Our method achieves adaptivity by varying the mesh resolution over the computational domain.</DRI_Approach> <DRI_Approach agreement="All_Equal">Our FLIP simulation performs computation on both a background volumetric mesh and on a set of particles.</DRI_Approach> <DRI_Approach agreement="All_Equal">Given a sizing function that indicates the desired spatial level of detail, our method first creates a tetrahedral mesh with varying spatial resolution, and then it locally changes the particle density by splitting and merging operations.</DRI_Approach> <DRI_Approach agreement="All_Equal">To compute the spatially-varying background grid, we start with the Delaunay tetrahedralization of a set of points distributed in a body-centered cubic lattice configuration.</DRI_Approach> <DRI_Approach agreement="All_Equal">In order to make the mesh resolution change over space, we use the octree-based grading method which was proposed by Labelle and Shewchuk [2007] and later adopted in several adaptive simulation environments [Chentanez et al. 2007; Wojtan and Turk 2008; Batty et al. 2010].</DRI_Approach> <DRI_Approach agreement="All_Equal">Similar to [Batty et al. 2010], we generate a new tetrahedral mesh every ten time steps, instead of rebuilding the mesh on every consecutive step.</DRI_Approach> <DRI_Approach agreement="All_Equal">Also, the tetrahedral mesh is only temporarily used for the pressure solver, so no information is transferred from one time step to the next by storing it on the grid.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Thus, we do not worry about re-sampling data when computing a new tetrahedral mesh.</DRI_Approach> <DRI_Approach agreement="All_Equal">We change the size and number of particles in our simulation with splitting and merging operations.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">For this, we modify the strategy of Ando et al. [2012] to work within our framework: at each remeshing step, we loop through the particles and determine whether the resolution needs to be changed.</DRI_Approach> <DRI_Approach agreement="All_Equal">If a particle is too small, then we merge it with its nearest neighboring particle, resulting in a particle whose radius is given by the combined volume of the two original particles.</DRI_Approach> <DRI_Approach agreement="All_Equal">If a given particle is bigger than the desired size, then the particle is split in two.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">The two new particles are placed randomly within the original particle’s radius and redistributed with a heuristic that attempts to fill in nearby gaps: We first compute the 24 midpoints m i between this particle and its 24 nearest neighbors.</DRI_Approach> <DRI_Approach agreement="All_Equal">Then we find the closest particle to each midpoint and store the squared distance as a weight ω i .</DRI_Approach> <DRI_Approach agreement="All_Equal">The new particle’s position is equal to the weighted average of all nearby midpoints: x new = ω i m i / ω i .</DRI_Approach> <DRI_Approach agreement="All_Equal">After a split or merge operation, the new particle’s velocity is computed using a volume-weighted average.</DRI_Approach> <DRI_Approach agreement="All_Equal">Also, we must take care to ensure that particles close to the surface do not introduce interfacial bumps when they split or merge; whenever we create a new particle that is less than 1.25 times its radius away from the surface (through either a split or a merge event), we move it in the surface normal direction such that its sphere lies exactly tangent to the liquid interface.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">Numerical viscosity in fluid simulations is tightly coupled to the spatial resolution resolving the flow.</DRI_Approach> <DRI_Approach agreement="All_Equal">We compensate for spatiallyvarying numerical viscosity caused by particles of various sizes in our simulation by adjusting the PIC/FLIP blending parameter in our FLIP simulation [Bridson 2008].</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">Given quantities Q i,PIC and Q i,FLIP computed at particle i from PIC and FLIP simulations, respectively, the new quantity Q i is computed as a weighted blend between the two:</DRI_Approach>
        
          
          Figure 4: For the perfectly planar particle placement shown in (a), the methods [Zhu and Bridson 2005] (b), [Yu and Turk 2010] (c), and [Adams et al. 2007] (d) do not result in a flat surface, while our method produces the desired result (e).
        
        
          14
          ν∆t ν∆t Q i = r i 2 Q i,PIC + (1 − r i 2 )Q i,FLIP
        
        <Sentence agreement="All_Equal">where r i is the radius of particle i and ν is the viscosity of the flow.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">We found that this strategy adequately eliminates any artifacts due to spatially varying numerical viscosity.</DRI_Approach> <DRI_Approach ann2="Sentence" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Unspecified">Sizing Functions We define the level of detail in our simulations with a spatially varying sizing function S(x).</DRI_Approach> <DRI_Approach agreement="All_Equal">We have experimented with several different sizing functions depending on factors such as distance to a camera, distance to the liquid surface, curvature of the liquid surface, measures of fluid turbulence, and arbitrary analytical number fields.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">Our simulator is versatile enough to cope with any of these sizing functions, resulting in efficient simulations with highly variable levels of detail.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">E.g.</Sentence><DRI_Unspecified ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">, Figure 1 showcases a simulation where smallest and largest cells differ by a factor of 128.</DRI_Unspecified> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">In all of the examples in this paper, the sizing function is defined as a combination of five different metrics:</DRI_Approach>
        
          15
          S(x) = max ( d(x), V (x, min(κ liquid (x), κ solid (x), e(x)) )
        
        <Sentence agreement="All_Equal">where x is the position of a point in space, and d(x) encodes the depth of the liquid by returning the absolute level set value of the liquid surface.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">This has the effect that motion near the surface has higher priority than motions far inside the bulk volume of the liquid.</DRI_Approach> <DRI_Approach agreement="All_Equal">V (x, y) is a view-dependent function that returns the value y if x is within the camera’s visible region and returns the maximum particle radius r max (representing the minimum surface resolution) otherwise.</DRI_Approach> <DRI_Approach ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">The next two metrics are designed to prioritize geometric detail of the liquid surface and of obstacles by computing a desired resolution based on cuvature.</DRI_Approach> <DRI_Approach ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">κ liquid (x) returns 0.8 divided by the extrapolated curvature of the liquid interface.</DRI_Approach> <DRI_Approach agreement="All_Equal">Similarly, κ solid (x) returns 1.6 W smooth (d solid , r max ) divided by the extrapolated curvature of the solid interface, where W smooth (x, h) is a smooth kernel function (1 − ||x|| 2 /h 2 ) 3 and d solid is the closest distance to the solid boundary.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">As a last component of our sizing function we found it beneficial to invest computational resources into keeping interesting motion of the flow field alive.</DRI_Approach> <Sentence ann2="DRI_Approach" agreement="3diff" ann1="Sentence" ann3="DRI_Outcome">Inspired by turbulence models (used e.g. in [Pfaff et al. 2010]), we have found that the strain tensor of the flow field reliably indicates detailed motions, and we compute e(x) as 30 divided by the Frobenius norm of the fluid strain tensor computed from the velocity field.</Sentence>
      
      
        <h1>5 Surface Representation</h1>
        <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">We also introduce a new method for computing an implicit surface from a set of particles.</DRI_Outcome_Contribution> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge_Goal" ann3="DRI_Approach">Given our set of FLIP particles with variable radii, we aim to implicitly represent the fluid surface by computing its signed distance function.</DRI_Approach> <DRI_Background agreement="All_Equal">Several useful methods for computing a surface from a collection of particles have been proposed in the past [Zhu and Bridson 2005; Adams et al. 2007; Yu and Turk 2010], but they tend to produce undesirably bumpy surfaces when considering particles of highly variable radii ( Figure 4 ).</DRI_Background> <DRI_Challenge_Goal ann2="DRI_Outcome" agreement="3diff" ann1="DRI_Challenge_Goal" ann3="DRI_Unspecified">In this section, we introduce a new strategy for computing an implicit surface from a set of particles of various sizes.</DRI_Challenge_Goal> <DRI_Challenge_Goal ann2="DRI_Challenge_Goal" agreement="2equal_1diff" ann1="DRI_Challenge_Goal" ann3="DRI_Approach">The main idea is to approximate the fluid surface with the union of the convex hulls of each triplet of nearby particles close to the surface.</DRI_Challenge_Goal> <DRI_Approach agreement="All_Equal">For each set of three FLIP particles near the surface, the convex hull forms a thickened triangle shape with rounded edges ( Figure 5 ).</DRI_Approach> <DRI_Approach agreement="All_Equal">We only consider particles that are less than a given distance apart, with the maximum distance equal to a constant scale factor l times the sum of the two particle radii.</DRI_Approach> <DRI_Approach agreement="All_Equal">A small l shows more surface details, while a larger l tends to fill in small concavities.</DRI_Approach> <DRI_Approach agreement="All_Equal">We used l = 2 for most of the simulations in this paper.</DRI_Approach> <DRI_Approach agreement="All_Equal">We ultimately represent our surface as the union of all such local convex hull shapes, and the minimum signed distance from these shapes to a point in space defines the outer part of our level set function.</DRI_Approach> <DRI_Approach agreement="All_Equal">In practice, we compute the local convex hull by finding the two outermost planes tangent to a set of three spheres.</DRI_Approach> <DRI_Approach ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">We efficiently compute the distance to these planes by analytically solving the polynomial system: ax 1 +by 1 +cz 1 +d = r 1 , ax 2 +by 2 +cz 2 +d = r 2 , ax 3 + by 3 + cz 3 + d = r 3 , a 2 + b 2 + c 2 = 1 .</DRI_Approach> <Sentence agreement="All_Equal">where r i and x i , y i , z i are the radius and x, y, z coordinates of particle i, respectively.</Sentence> <DRI_Approach agreement="All_Equal">a, b, c, d are the variables defining our plane with the signed distance function ax + by + cz + d = 0.</DRI_Approach> <DRI_Approach agreement="All_Equal">Intuitively, the first three equations ensure that the plane is the right distance away from each particle with the normal facing away from them, and the final equation ensures that the plane equation is normalized to a distance function.</DRI_Approach> <DRI_Approach agreement="All_Equal">These four equations represent the intersection of three hyperplanes and a hypercylinder in 4D {a, b, c, d} space.</DRI_Approach> <DRI_Approach agreement="All_Equal">We solve this system analytically by first finding the line of common intersection of the first three equations, and then intersecting this line with the cylinder represented by the final equation.</DRI_Approach> <DRI_Approach agreement="All_Equal">The system has two solutions, representing the top and bottom planes of our convex hull shape.</DRI_Approach> <DRI_Approach agreement="All_Equal">The above calculation describes how to find the planar regions of the convex hull of a set of three spheres.</DRI_Approach> <DRI_Approach agreement="All_Equal">By computing the conic and spherical convex hull facets ( Figure 5 , bottom right) in a similar fashion, we can easily compute the signed distance between this convex hull and a point in space.</DRI_Approach> <DRI_Approach agreement="All_Equal">To evaluate our final level set value, we compute the minimum signed distance from a query point to all nearby convex hulls.</DRI_Approach> <DRI_Approach agreement="All_Equal">We evaluate the level set on each of the vertices of our adaptive BCC mesh, and we extract a triangle mesh using a marching tetrahedra algorithm.</DRI_Approach> <DRI_Approach agreement="All_Equal">We then perform a light mesh smoothing to increase the reliability of any curvature computations.</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The algorithm as described works perfectly for computing the level set outside of our particle surface, but it may lead to small gaps inside.</DRI_Outcome> <DRI_Approach agreement="All_Equal">To avoid the creation of holes, we temporarily reassign each particle’s radius: r i temp = max(r i , −kφ i ) where φ i is the particle’s stored level set value from the previous time step, and k is a constant set to 0.75 in our simulations.</DRI_Approach> <DRI_Approach agreement="All_Equal">Using this temporary radius to compute the signed distance as described above will remove erroneous gaps inside the liquid.</DRI_Approach> <DRI_Approach agreement="All_Equal">We need to compute liquid surfaces both for final visualization as well as for several calculations during the progress of our simulation.</DRI_Approach> <DRI_Approach agreement="All_Equal">For the final visualization, we compute an especially highresolution BCC mesh from all of our particles and proceed with the algorithm above.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The final surface creation is trivially parallelized, and takes around five minutes average per frame for all of our simulations.</DRI_Approach> <DRI_Approach agreement="All_Equal">We attempt to speed up the surface creation routine used for simulation computations by computing on the moderate-resolution BCC mesh used for simulation and ignoring ballistic particles (Section 3).</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">We compare our surface creation routine with a few existing methods in Figure 4 .</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Most previous algorithms perform poorly in this comparison because they were not designed for particles with varying radii.</DRI_Outcome>
        
          
          Figure 5: The 2D version of our surface creation algorithm takes a pair of particles (top left) and computes their convex hull (bottom left). In 3D, we convert three nearby particles (top right) into a convex hull (bottom right) consisting of spherical (orange), conic (dark blue), and planar (light blue) segments.
        
      
      
        <h1>6 Implementation</h1>
        <DRI_Unspecified agreement="All_Equal">At this point we have described all of the components of our simulator.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">The resulting algorithm can be seen in Algorithm 1.</DRI_Unspecified> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">In the beginning of each step (line 2), we typically compute the level-set for the current particle configuration as described in Section 5.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">We require the distance to the surface in several steps of our algorithm, so we store the level set values for each particle (line 3).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">When enough time has passed to trigger an update of the mesh, it becomes necessary to evaluate the sizing function.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">At this point, additional user-defined sizing functions could be computed as well.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">Having the information from the sizing functions ready, we create a new BCC mesh and perform particle merging and splitting.</DRI_Approach> <Sentence agreement="All_Equal">For mapping the particle velocities onto the grid (line 9) we use an SPH-like kernel function, which is weighted by the particle volume: max(v i (4r i 2 /d 2 − 1), 0), where v i is the particle volume and d is
        Algorithm 1: One step of our simulation algorithm.</Sentence> <Sentence agreement="All_Equal">1 begin 2 Compute simulation surface S 3 Pre-compute φ for all particles 4 Correct particle positions x i 5 if Mesh update necessary then 6 Evaluate sizing function S(x) at x i 7 Build octree and BCC mesh 8 Merge and split particles 9 Compute mesh velocity u from particle velocities 10 Extrapolate u outside the liquid 11 Solve pressure p on the tetrahedral mesh, update u 12 Update particle velocities with gradient of p 13 Advect particles with u
        the distance to the particle center normalized with its radius.</Sentence> <DRI_Outcome ann2="DRI_Approach" agreement="3diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">The particle velocity update of line 12 uses barycentric interpolations as explained in Section 3.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="3diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">Likewise, the grid-based velocity extrapolation of line 10 uses the nodal velocities of Section 3.</DRI_Outcome> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">A time step is completed by performing the pressure projection and advecting the particles in the resulting divergence-free velocity field.</DRI_Approach>
      
      
        <h1>7 Results and Discussion</h1>
        <DRI_Approach agreement="All_Equal">To evaluate the performance and robustness of our method in comparison to previous work we have performed an extensive series of tests.</DRI_Approach> <DRI_Unspecified agreement="All_Equal">A selection of these can be found in the accompanying comparison video.</DRI_Unspecified> <DRI_Outcome agreement="All_Equal">One comparison that is particularly interesting is the one comparing our method to an FVM based simulation.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Using a graded BCC mesh leads to problems with the latter, as the position of the circumcenter lies exactly on a face for the graded tetrahedrons.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">In the graded region, this can result in two pressure samples from adjacent tetrahedra being placed at the exact same position.</DRI_Outcome> <DRI_Background ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">To alleviate this problem, [Batty et al. 2010] propose to slightly offset the pressure samples from the faces.</DRI_Background> <DRI_Outcome agreement="All_Equal">However, our implementation of their method exhibited slow convergence and the velocity artifacts despite this fix.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">The influence of the different components of our sizing function on the evolution of a simulation is difficult to depict with static images, so we refer to the accompanying video for a comparison.</DRI_Outcome> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">To evaluate the basis of our adaptive model without any influence of the camera dependent sizing function, we have simulated the simple geometric configuration shown in Figure 3 .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">For this setup, resolutions from 8 to 256 were used, resulting in 6 levels of adaptivity.</DRI_Approach> <DRI_Unspecified ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">Timing information for the main steps of our algorithm over the course of this simulation can be found in Figure 8 and Figure 9 .</DRI_Unspecified> <DRI_Approach agreement="All_Equal">For this simulation, the initial configuration consisted of 168, 161 particles, and momentarily peaked up to 1, 048, 776 during the maximal extent of the splash (settling down again to around 250 thousand in the end).</DRI_Approach> <DRI_Approach agreement="All_Equal">Note that a full sampling of the initial configuration with a regular grid would have required approximately 6 million particles.</DRI_Approach> <DRI_Outcome agreement="All_Equal">Our measurements show that the run-time of our method has a strong linear relationship to the number of particles, and thus the visual complexity of the simulation.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">The per-frame time is low at the beginning and end of the simulation, but strongly peaks during the complex splash in its middle.</DRI_Outcome> <DRI_Unspecified ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">Our visibility sizing function is highlighted by the setup shown in Figure 6 .</DRI_Unspecified> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">Here the computational resources are focused on the visible region of a rotating camera, as the liquid splashes around a U-shaped corridor.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Our solver efficiently resolves the complex motion near the camera, while effectively reducing the computational cost for parts that are not visible.</DRI_Outcome> <Sentence agreement="All_Equal">The simulation of Figure 7 shows</Sentence>
        
          
          Figure 6: Our visibility sizing function: as the liquid flows along the U-shaped corridor, the visible volume is simulated with a high resolution (surface shown in top row), while regions outside of the view frustrum are coarsened (particle view in bottom row).
        
        
          
            <h1> Setup Min. ∆x −1 Min. ∆x s −1 Max. ∆x −1 Duration frames</h1>
            
              
              
                
                   Figure 3
                   8
                   16
                   256
                   5h:09m
                   240
                
                
                   Figure 6
                   16
                   32
                   256
                   4h:26m
                   330
                
                
                   Figure 7
                   16
                   64
                   512
                   5h:55m
                   480
                
                
                   Figure 1
                   8
                   32
                   1024
                   12h:8m
                   160
                
              
            
          
          Setup Min. ∆x −1 Min. ∆x −1 s Max. ∆x −1 Duration frames Figure 3 8 16 256 5h:09m 240 Figure 6 16 32 256 4h:26m 330 Figure 7 16 64 512 5h:55m 480 Figure 1 8 32 1024 12h:8m 160
          Table 1: Resolutions and running times for our simulations (not including final surface creation). Here, ∆x −1 and ∆x −1 s denote the
        
        <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="Sentence">number of BCC cells along one spatial axis for the simulation and for the surface generation, respectively.</Sentence> <DRI_Unspecified ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">The simulations were run on a workstation with an Intel Core i7-3960X CPU with 3.30GHz running under Linux.</DRI_Unspecified>
        <Sentence agreement="All_Equal">a liquid interacting with a highly detailed obstacle.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">The κ solid component of our sizing function ensures that geometrically complex regions near the obstacle are simulated with higher accuracy.</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">In this way, we can resolve the detailed flow of liquid through the holes in the obstacle.</DRI_Outcome> <DRI_Unspecified agreement="All_Equal">Figure 1 shows a situation that would be challenging to simulate with a regular solver.</DRI_Unspecified> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Without adaptivity, the large open liquid surface with complex splashes in a localized region would require huge amounts of computational resources.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Our method can simulate this setup very efficiently, and in a fully coupled manner with an effective high resolution.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">The large open region is successfully coarsened by our sizing function, resulting in subtle wave motions around the splashes.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">In this case, the whole simulation with 8 different octree levels and a maximum resolution of up to 1024 cells took on average only 4.6 minutes per frame to compute.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Just to illustrate the amount of detail in this setup – our adaptive version initially used 1.7 million particles, while a regular sampling at the finest resolution would have required roughly 400 million.</DRI_Outcome> <DRI_Unspecified ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">Further runtime and resolution details for our simulations can be found in Table 1 .</DRI_Unspecified> <DRI_Unspecified ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">Discussion We found our discretization (Section 3) beneficial in a number of ways.</DRI_Unspecified> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">We store the pressure variables on tetrahedral vertices, and there are far fewer vertices than tetrahedra in a given mesh.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Consequently, the pressure solve has fewer variables and is faster to solve.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Also, by counting degrees of freedom and constraints, we can see that our discretization prevents the locking ar- tifacts which are common in other methods.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">However, the lower number of pressure constraints also implies that the highest frequencies of the velocity field may be unconstrained.</DRI_Outcome> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">In our case a regularization via PIC interpolation acts to diminish any highfrequency artifacts.</DRI_Approach> <DRI_Approach agreement="All_Equal">Our method uses a FLIP scheme instead of a purely Eulerian method.</DRI_Approach> <DRI_Approach agreement="All_Equal">We store all physical variables on the FLIP particles, so information is carried from one time step to the next in a Lagrangian manner.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">As a result, we are allowed to aggressively remesh the tetrahedral background grid without worrying about excessive damping or re-sampling artifacts.</DRI_Approach> <DRI_Background agreement="All_Equal">On the other hand, FLIP simulations have a well-known problem of creating noisy particle distributions, because there are typically several times more particles than velocity variables on the background grid.</DRI_Background> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">We utilize particle repositioning to improve the distribution quality, at the expense of slight inaccuracies due to displacing physical variables.</DRI_Approach> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">We noticed that our new surface creation routine is essential for maintaining detailed simulations in the presence of accurate freesurface boundary conditions.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">One major benefit of our method is that it can easily create perfectly flat surfaces from a mixture of differently-sized particles.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">These flat surfaces represent the equilibrium state of a fluid simulation, so our animations are able to smoothly settle down as time progresses.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Without a method for accurately reproducing flat surfaces, second-order boundary conditions will introduce additional forces in the locations of surface bumps, which artificially prevent a simulation from settling down.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">While we believe that our surface creation routine is indispensable, it is quite expensive to compute.</DRI_Outcome> <DRI_FutureWork agreement="All_Equal">In the future we would like to optimize the surface computation.</DRI_FutureWork> <DRI_Outcome agreement="All_Equal">Our simulations perform quite well for large differences in resolutions, but we have only been able to push them to a certain point in our current implementation.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">We found that using too sharp of a grading in our sizing function can place coarse and fine simulation elements too close together and potentially result in artifacts.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">For example, when small particles land in very coarse cells after violent splashes, these particles can get stuck in mid air.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Occasionally, this can also lead to an overly strong weight for such particles during the velocity mapping, resulting in momentum artifacts.</DRI_Outcome> <Sentence agreement="All_Equal">Our adaptive numerical viscosity in Eq.</Sentence> <Sentence agreement="All_Equal">(14) can also exhibit dangerously small damping values for very fine resolutions, so we clamped the blending coefficient to a minimum value of 0.1 in Figure 1 .</Sentence> <DRI_Unspecified ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">In Section 4 we introduced a novel collection of sizing functions for adaptively selecting details from a fluid simulation.</DRI_Unspecified> <DRI_Outcome ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">While we presented specific parameters for the sake of reproducibility, these values were not meticulously tuned and are certainly not optimal.</DRI_Outcome> <DRI_FutureWork agreement="All_Equal">The task of choosing an ideal sizing function is still an open problem that we are interested in pursuing in the future.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">In particular, we are interested in taking more temporal information into account.</DRI_FutureWork> <DRI_FutureWork ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_FutureWork">This could lead to more gradual changes in resolution, at the expense of a slightly higher particle count.</DRI_FutureWork>
        
          Figure 8: This graph shows durations for the different parts of our algorithm over the course of the simulation from Figure 3 . Note that we only include the computationally more expensive steps here, and not the re-meshing (which is done in intervals).
        
        
          Figure 9: The time required for our re-meshing and particle merging &amp; splitting computations over time for Figure 3 . Note that we perform them only every ten simulation steps.
        
        
          
          Figure 7: A simulation of detailed flow through a complex obstacle. The liquid correctly flows through the orifices at the center of the filigree.
        
      
      
        <h1>8 Conclusions and Outlook</h1>
        <DRI_Outcome_Contribution agreement="All_Equal">We have presented a novel framework for highly adaptive liquid simulation.</DRI_Outcome_Contribution> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Approach">In our method, a novel, robust discretization works together with accurate embedded boundary conditions and a flexible sizing function to allow for aggressive adaptivity and high computational performance.</DRI_Approach> <DRI_Outcome ann2="DRI_Approach" agreement="3diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">In this way, we can efficiently compute tough simulation setups, such as large surfaces with very localized details.</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Approach" agreement="3diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome">We have additionally presented a novel surface creation method that yields smooth surfaces in the presence of strongly varying particle radii, which turned out to be an important building block for our framework.</DRI_Outcome_Contribution> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">We chose a BCC mesh generation because it is, to the best of our knowledge, the fastest way to generate high-quality meshes.</DRI_Approach> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">However, despite its efficiency, mesh generation is still a bottleneck for our simulation.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">This is partly due to the fact that it is a mostly serial operation that is difficult to parallelize (most other steps of our algorithm parallelize easily).</DRI_Outcome> <DRI_FutureWork agreement="All_Equal">So, instead of computing the mesh from scratch each time, we are interested in exploring techniques for continuous re-meshing.</DRI_FutureWork> <DRI_Outcome agreement="All_Equal">Also, our choice of piece-wise constant basis functions for velocity indicates that our discretization could lead to difficulties when it is used for diffusion or viscosity solves.</DRI_Outcome> <DRI_FutureWork agreement="All_Equal">It will be interesting to see how these could be incorporated into our framework.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Finally, we are highly interested in applying our method to other types of phenomena, such as smoke and fire simulations, or visco-elastic materials.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">It will be very interesting to leverage the benefits of our framework for extreme adaptivity in these situations.</DRI_FutureWork>
      
      
        <h1>Acknowledgements</h1>
        <DRI_Unspecified agreement="All_Equal">We would like to thank the anonymous reviewers for their helpful feedback.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">We also wish to thank Reiji Tsuruno for providing us with computational resources, and Pascal Clausen as well as Ramprasad Sampath for constructive discussions.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">This work was supported by the Japan Society for the Promotion of Science (JSPS).</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">Finally, we would like to express our gratitude to the authors of the ANN library, which we use for kd-tree look-ups, and to the Mitsuba renderer, which we have used to render all images in this paper.</DRI_Unspecified>
      
      
        <h1>References</h1>
        
          A DAMS , B., P AULY , M., K EISER , R., AND G UIBAS , L. J. 2007. Adaptively sampled particle fluids. In ACM SIGGRAPH 2007 papers, 48.
          A NDO , R., T HUEREY , N., AND T SURUNO , R. 2012. Preserving Fluid Sheets with Adaptively Sampled Anisotropic Particles. IEEE Transactions on Visualization and Computer Graphics 18 (8), 1202–1214.
          B ATTY , C., AND B RIDSON , R. 2008. Accurate viscous free surfaces for buckling, coiling, and rotating liquids. In Proceedings of the 2008 ACM/Eurographics Symposium on Computer Animation, 219–228.
          B ATTY , C., B ERTAILS , F., AND B RIDSON , R. 2007. A fast variational framework for accurate solid-fluid coupling. ACM Trans. Graph. 26, 3 (July).
          B ATTY , C., X ENOS , S., AND H OUSTON , B. 2010. Tetrahedral embedded boundary methods for accurate and flexible adaptive fluids. In Proceedings of Eurographics.
          B HATTACHARYA , H., G AO , Y., AND B ARGTEIL , A. W. 2011. A level-set method for skinning animated particle data. In Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation.
          B OYD , L., AND B RIDSON , R. 2012. Multiflip for energetic twophase fluid simulation. ACM Trans. Graph. 31, 2, 16:1–16:12.
          B RIDSON , R. 2008. Fluid Simulation for Computer Graphics. AK Peters/CRC Press.
          B ROCHU , T., B ATTY , C., AND B RIDSON , R. 2010. Matching fluid simulation elements to surface geometry and topology. ACM Trans. Graph. 29, 4 (July), 47:1–47:9.
          C HENTANEZ , N., F ELDMAN , B. E., L ABELLE , F., O’B RIEN , J. F., AND S HEWCHUK , J. R. 2007. Liquid simulation on lattice-based tetrahedral meshes. In Proceedings of the 2007 ACM SIGGRAPH/Eurographics Symposium on Computer Animation, Eurographics Association, 219–228.
          C LAUSEN , P., W ICKE , M., S HEWCHUK , J., AND O’B RIEN , J. 2013. Simulating liquids and solid-liquid interactions with Lagrangian meshes. ACM Trans. Graph..
          E NRIGHT , D., N GUYEN , D., G IBOU , F., AND F EDKIW , R. 2003. Using the Particle Level Set Method and a Second Order Accurate Pressure Boundary Condition for Free-Surface Flows. Proc. of the 4th ASME-JSME Joint Fluids Engineering Conference.
          E NRIGHT , D., L OSASSO , F., AND F EDKIW , R. 2005. A fast and accurate semi-Lagrangian particle level set method. Comput. Struct. 83, 6-7, 479–490.
          H ARLOW , F., AND W ELCH , E. 1965. Numerical calculation of time-dependent viscous incompressible flow of fluid with free surface. Phys. Fluids 8 (12), 2182–2189.
          H ONG , W., H OUSE , D. H., AND K EYSER , J. 2009. An adaptive sampling approach to incompressible particle-based fluid. In TPCG, Eurographics Association, W. Tang and J. P. Collomosse, Eds., 69–76.
          I RVING , G., S CHROEDER , C., AND F EDKIW , R. 2007. Volume conserving finite element simulations of deformable models. ACM Trans. Graph. 26, 3 (July).
          K LINGNER , B. M., F ELDMAN , B. E., C HENTANEZ , N., AND O’B RIEN , J. F. 2006. Fluid animation with dynamic meshes. ACM Trans. Graph. 25, 3, 820–825.
          L ABELLE , F., AND S HEWCHUK , J. R. 2007. Isosurface stuffing: Fast tetrahedral meshes with good dihedral angles. ACM Trans. Graph. 26, 3 (July).
          L EW , A. J., AND B USCAGLIA , G. C. 2008. A discontinuousgalerkin-based immersed boundary method. International Journal for Numerical Methods in Engineering 76, 4, 427–454.
          L OSASSO , F., G IBOU , F., AND F EDKIW , R. 2004. Simulating water and smoke with an octree data structure. ACM Trans. Graph. 23, 3 (Aug.), 457–462.
          L OSASSO , F., F EDKIW , R., AND O SHER , S. 2005. Spatially adaptive techniques for level set methods and incompressible flow. Computers and Fluids 35, 2006.
          M ISZTAL , M. K., B RIDSON , R., E RLEBEN , K., B ÆRENTZEN , J. A., AND A NTON , F. 2010. Optimization-based fluid simulation on unstructured meshes. In VRIPHYS, Eurographics Association, 11–20.
          M ULLEN , P., C RANE , K., P AVLOV , D., T ONG , Y., AND D ES BRUN , M. 2009. Energy-preserving integrators for fluid animation. ACM Trans. Graph. 28 (July), 38:1–38:8.
          P FAFF , T., T HUEREY , N., C OHEN , J., T ARIQ , S., AND G ROSS , M. 2010. Scalable fluid simulation using anisotropic turbulence particles. In ACM Transactions on Graphics (TOG), vol. 29, ACM, 174.
          S IN , F., B ARGTEIL , A. W., AND H ODGINS , J. K. 2009. A pointbased method for animating incompressible flow. In Proceedings of the ACM SIGGRAPH/Eurographics Symposium on Computer Animation.
          S OLENTHALER , B., AND G ROSS , M. 2011. Two-scale particle simulation. ACM Trans. Graph. 30, 4 (July), 81:1–81:8.
          S TAM , J. 1999. Stable fluids. In Proceedings of SIGGRAPH ’99, ACM, 121–128.
          W OJTAN , C., AND T URK , G. 2008. Fast viscoelastic behavior with thin features. ACM Trans. Graph. 27, 3, 1–8.
          Y U , J., AND T URK , G. 2010. Reconstructing surfaces of particlebased fluids using anisotropic kernels. In Proceedings of the 2010 ACM SIGGRAPH/Eurographics Symposium on Computer Animation, Eurographics Association, 217–225.
          Z HU , Y., AND B RIDSON , R. 2005. Animating sand as a fluid. ACM Trans. Graph. 24, 3 (July), 965–972.
        
      
      
        <h1>A Ghost Fluid Coefficients</h1>
        <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">Here we describe how to compute the ghost fluid coefficients θ n given the 4 × 4 pressure matrix entries of a single tetrahedron.</DRI_Approach> <Sentence agreement="All_Equal">Reorganizing Eq.</Sentence> <Sentence agreement="All_Equal">(11) gives:</Sentence>
        
          16
          λ 2 + αw 1 a + αw 2 b + αw 3 p 1 b 1 a + βw 1 λ 3 + βw 2 c + βw 3 p 2 = b 2 . b + γw 1 c + γw 2 λ 4 + γw 3 p 3 b 3
        
        <DRI_Approach agreement="All_Equal">Note that each of the θ n has two degree of freedom, and thus each w n also has two degrees of freedom.</DRI_Approach> <DRI_Approach agreement="All_Equal">As we know that the resulting matrix needs to be symmetric, which gives us the following constraints: a + αw 2 = a + βw 1 , b + γw 1 = b + αw 3 , and c + βw 3 = c + γw 2 .</DRI_Approach> <DRI_Approach agreement="All_Equal">As the w n linearly depend on θ n , that means: αθ 2 = βθ 1 , γθ 1 = αθ 3 , and βθ 3 = γθ 2 .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">When we re-write these constraints in matrix form, and include the barycentric coordinate constraint θ 1 + θ 2 + θ 3 = 1 we get the following linear system:</DRI_Approach>
        
          17
           −β α 0   0  γ 0 −α θ 1 0   0 1 −γ 1 β 1   θ θ 3 2 =   1 0  
        
        <DRI_Approach agreement="All_Equal">As the rank of top three rows of the matrix is 2, we can drop one of them.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">Removing the first row from the system gives us the following full-rank, 3 × 3 matrix:</Sentence>
        
          18
          γ 0 −α θ 1 0 0 −γ β θ 2 = 0 1 1 1 θ 3 1
        
        <Sentence agreement="All_Equal">The analytical solution of this system is:</Sentence>
        
          19
          θ 1 1 α θ 2 = β . θ 3 α + β + γ γ
        
        <DRI_Approach agreement="All_Equal">This means that for our discretization, the ghost pressure coefficients θ n are given by the tetrahedron’s matrix entries from Eq.10.</DRI_Approach> <DRI_Approach agreement="All_Equal">More specifically, by those for the vertex that is located outside of the liquid, i.e., α, β and γ.</DRI_Approach> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">Substituting this equation into Eq.9 and Eq.6 yields the final equation for the ghost pressure Eq.</Sentence> <Sentence agreement="All_Equal">(12).</Sentence>
      
    
  
</Document>