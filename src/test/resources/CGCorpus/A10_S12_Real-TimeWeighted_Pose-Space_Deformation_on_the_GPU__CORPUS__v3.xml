<?xml version="1.0" encoding="UTF-8" ?>
<Document corpusVersion="3" name="A10_S12_Real-TimeWeighted_Pose-Space_Deformation_on_the_GPU">
  
    0f19576cc37e43e4757200e19f6a45f9584905abee6902833a23266c931cee03
    3wxl
    http://dx.doi.org/10.1111/j.1467-6346.2008.01649.x
  
  
    
      Volume 25 (2006), Number 3
      EUROGRAPHICS 2006 / E. Gröller and L. Szirmay-Kalos (Guest Editors)
      
        <article-title>Real-Time Weighted Pose-Space Deformation on the GPU</article-title>
      
      <Sentence agreement="All_Equal">Taehyun Rhee †1 J.P. Lewis 1 University of Southern California, U.S.A. 2 Stanford University, U.S.A.
      WPSD (Weighted Pose Space Deformation) is an example based skinning method for articulated body animation.</Sentence> <Sentence ann2="DRI_Background" agreement="3diff" ann1="Sentence" ann3="DRI_Challenge_Goal">The per-vertex computation required in WPSD can be parallelized in a SIMD (Single Instruction Multiple Data) manner and implemented on a GPU.</Sentence> <DRI_Challenge ann2="DRI_Background" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_Challenge_Hypothesis">While such vertex-parallel computation is often done on the GPU vertex processors, further parallelism can potentially be obtained by using the fragment processors.</DRI_Challenge> <DRI_Challenge_Goal ann2="DRI_Outcome_Contribution" agreement="3diff" ann1="DRI_Challenge_Goal" ann3="DRI_Approach">In this paper, we develop a parallel deformation method using the GPU fragment processors.</DRI_Challenge_Goal> <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">Joint weights for each vertex are automatically calculated from sample poses, thereby reducing manual effort and enhancing the quality of WPSD as well as SSD (Skeletal Subspace Deformation).</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome">We show sufficient speed-up of SSD, PSD (Pose Space Deformation) and WPSD to make them suitable for real-time applications.</DRI_Outcome>
    <h2>Categories and Subject Descriptors (according to ACM CCS): </h2>I.3.1 [Computer Graphics]: Hardware ArchitectureParallel processing, I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling-Curve, surface, solid and object modeling, I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism-Animation.
      
        
          c The Eurographics Association
        
        
          Blackwell Publishing 2006. Published by Blackwell Publishing
        
        
          Garsington Road
        
        
          Oxford OX4 2DQ
        
        
          UK
        
        
          Main Street
        
        
          Malden
        
        
          MA
        
        
          USA.
        
      
      T. Rhee, J.P. Lewis, and U. Neumann / EG 2006
      † trhee@usc.edu ‡ zilla@computer.org § uneumann@graphics.usc.edu
      ‡2 and Ulrich Neumann §1
    
    
      
        <h1>1. Introduction</h1>
      
      <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Skinning is an important part of realistic articulated body animation and is an important topic of computer graphics and animation.</DRI_Background> <DRI_Background agreement="All_Equal">Generally, skinning can be categorized into algorithmic, physically-based, and example-based methods.</DRI_Background> <DRI_Challenge agreement="All_Equal">Although widely used, simple algorithmic skinning schemes cannot capture the complexity and subtlety of real skin deformation, and revised approaches will be required to increase character animation realism.</DRI_Challenge> <DRI_Background agreement="All_Equal">Physically-based skinning is based on the biomechanics of skin deformation arising from the motions of muscles and tendons.</DRI_Background> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">Although this approach can generate physically accurate simulations of each layer, it is not at present suitable for real time applications such as gaming due to the large computation required.</DRI_Challenge> <DRI_Background agreement="All_Equal">Example-based methods capture some of the complexity of real skin deformation by interpolating scanned or sculpted examples of the desired skin shape in various poses.</DRI_Background> <DRI_Background agreement="All_Equal">Al-
      though this requires gathering a sufficient number of samples and some pre-calculation, example-based methods can potentially be used in real-time applications due to their relatively simple real-time computation.</DRI_Background> <DRI_Background agreement="All_Equal">Weighted pose space deformation (WPSD) is an example based skinning method that generates high quality skinning with a limited number of sample poses [KM04].</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Although it can generate an accurate skinning, it requires more computation than the original pose space deformation (PSD) [LCF00], since joint distances are computed independently for each vertex.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">As such, this method has not been suitable for real-time applications.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Furthermore, both WPSD and SSD require joint weights for each vertex, and accurate joint weights are required to achieve good results.</DRI_Background> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">However, the weights are usually manually generated by artists, which requires effort and great skill in the case of a complex skeletal system such as the human hand.</DRI_Challenge> <DRI_Challenge_Goal ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Challenge_Goal" ann3="DRI_Challenge_Goal">In this paper, we present a parallel WPSD algorithm (including automatic determination of joint weights) suitable for SIMD architectures such as current GPUs.</DRI_Challenge_Goal> <DRI_Approach agreement="All_Equal">The joint
	  weights for each vertex are automatically computed from the sample poses.</DRI_Approach> <DRI_Approach ann2="DRI_Outcome" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Challenge_Hypothesis">This can enhance the skinning quality not only of SSD but also WPSD, since both methods require accurate joint weight values.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge_Hypothesis">The deformation required in WPSD and SSD is independent for each vertex and this per-vertex computation can be parallelized in a SIMD architecture.</DRI_Approach> <DRI_Background ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">The GPU is a general SIMD architecture having one-sided (unidirectional) communication to texture memory.</DRI_Background> <DRI_Approach agreement="All_Equal">We demonstrate our parallel WPSD method using GPU fragment processors.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">In our experiments, we can speed up SSD, PSD, as well as WPSD to around 20 times faster than on the CPU (from 1.2FPS to 25FPS speed-up of WPSD on a detailed model having 22836 triangles with 11574 vertices) using a modern graphics card, thus making WPSD a feasible real-time skinning solution for various applications including games, virtual reality, and other real-time simulations.</DRI_Approach>
      
        <h1>2. Related work</h1>
        <DRI_Background agreement="All_Equal">Many commercial software packages generate skin deformation arising from joint movement using a method known as (linear blend) skinning, Skeletal Subspace Deformation (SSD), enveloping, etc., based in part on work published by Thalmann et al. [MTLT88].</DRI_Background> <DRI_Background agreement="All_Equal">SSD is based on the weighted blending of affine transformations of each joint and used in many real-time applications due to its simple and fast computation.</DRI_Background> <DRI_Background agreement="All_Equal">However, it also exhibits some well known artifacts such as skin that collapses around the joints at increasing bend angles, and a variety of solutions for these problems have been published [Web00, WP02, MTG03, KZ05].</DRI_Background> <DRI_Background agreement="All_Equal">Recently, example-based methods [LCF00, SRC01, ACP02, KJP02, KM04] have permitted more complex skinning effects such as muscle bulges and major wrinkles, while also addressing the artifacts of simple algorithmic schemes.</DRI_Background> <DRI_Background agreement="All_Equal">In these methods, a number of provided (scanned or sculpted) samples of the desired skin shape are simply interpolated based on the creature’s pose (and possibly additional abstract control “dimensions”).</DRI_Background> <DRI_Background agreement="All_Equal">These example-based methods can also be considered as a non-parametric approach to skin deformation.</DRI_Background> <DRI_Background agreement="All_Equal">In common with non-parametric sampling methods in texture synthesis (and more generally in statistical regression), the amount of memory for these methods grows with the number of training samples, but arbitrary distributions can be approximated.</DRI_Background> <DRI_Background agreement="All_Equal">Some of the most impressive example-based results to date are those of Kurihara and Miyata’s hand model derived from medical images [KM04].</DRI_Background> <DRI_Background agreement="All_Equal">Since acquiring 3D medical images is relatively expensive, they developed weighted pose space deformation (WPSD) to generate proper skinning from a limited number of pose samples.</DRI_Background> <DRI_Background agreement="All_Equal">They modify the distance between poses using the joint weights of each vertex to provide a more appropriate distance measure for skinning.</DRI_Background> <DRI_Background agreement="All_Equal">Although the joint weights for each vertex are important data for SSD and WPSD calculations, they have traditionally been manually generated by skilled artists.</DRI_Background> <DRI_Background agreement="All_Equal">Least-squares based vertex weight estimation was shown in the skinning methods [WP02, MTG03].</DRI_Background> <DRI_Background agreement="All_Equal">James et al. describe mesh based skinning including estimation of bone parameters and vertex weights for each bone [JT05].</DRI_Background> <DRI_Background agreement="All_Equal">In their paper, the vertex weights of each joint are calculated by NNLS (non-negative least squares) and we derive a similar approach to calculate weights for SSD and WPSD.</DRI_Background> <DRI_Background agreement="All_Equal">In recent years, since the performance of GPUs has been improving more rapidly than that of CPUs, and GPUs have many processing units serving as a SIMD parallel architecture, many algorithms have been accelerated by GPU programming [LHK ∗ 04, PF05, GPG].</DRI_Background> <DRI_Background agreement="All_Equal">Deformation and skinning algorithms can also be enhanced by GPUs and several papers have profited from this [JP02, KJP02, BK05, JT05].</DRI_Background> <DRI_Background agreement="All_Equal">However, in previous research, since vertex information cannot be accessed in the fragment program, GPU-based vertex deformation is usually performed by vertex programs.</DRI_Background> <DRI_Challenge_Goal ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Challenge_Goal" ann3="DRI_Challenge_Goal">In this paper, we develop a parallel WPSD method using the fragment processors to gain greater parallelism and performance.</DRI_Challenge_Goal> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Person-specific data modeling and its deformation is also an interesting topic in realistic articulated body simulation.</DRI_Background> <DRI_Background agreement="All_Equal">Rhee et al. described human hand modeling from surface anatomy of the person [RNL06].</DRI_Background> <DRI_Background agreement="All_Equal">Anguelov et al. developed shape completion and animation of people, derived from the set of range scan data and example based deformation in pose and shape space [ASK ∗ 05].</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Physically inspired skinning should be also recognized as another important area of articulated body animation.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">However, we entrust the review of the subject to the recent related papers [AHS03, CBC ∗ 05, PCLS05, SNF05].</DRI_Background>
      
      
        <h1>3. Skin deformation</h1>
        <Sentence agreement="All_Equal">Example-based skinning problems can be described by the following general equation,</Sentence>
        
          1
          v(p a ) = S(v 0 + D(p a ))
        
        <Sentence agreement="All_Equal">where p a is an arbitrary pose, v(p a ) is a vertex of a deformed target surface of the arbitrary pose, v 0 is an undeformed (rest pose) vertex, S is the SSD function, and D(p a ) is a displacement as a function of the arbitrary pose.</Sentence> <DRI_Approach agreement="All_Equal">In skeletal subspace deformation the displacement D(p a ) is omitted and the target surface is calculated by SSD as a blend of affine transforms of v 0 [section 3.1].</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">Skinning methods related to PSD use the displacement of an arbitrary pose D(p a ), calculated by interpolation in pose space [section 3.2].</DRI_Approach>
        c The Eurographics Association and Blackwell Publishing 2006.
        T. Rhee, J.P. Lewis, and U. Neumann / EG 2006
        
          
        
        <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">(a)
        (b)</Sentence>
        
          
        
        <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">(d)
        (e)</Sentence>
        
          Figure 1: Skinning result of each algorithm: (a) SSD, (b) PSD, (c) WPSD, (d) Difference between SSD and PSD (blue dotted area), (e) Difference between SSD and WPSD (blue dotted area), (f) Difference between PSD and WPSD (blue dotted area); areas around blue and red arrows represent unexpected results of SSD and PSD respectively.
        
      
      
        <h1>3.1. Skeletal subspace deformation (SSD)</h1>
        <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">SSD [MTLT88] is based on the weighted blending of an affine transformation of each joint by equation 2.</DRI_Approach>
        
          2
          n joint v a = S(v 0 ) = ( ∑ w j T j )v 0 j=1
        
        <Sentence agreement="All_Equal">where n joint is the number of joints, v a is a vertex in an arbitrary pose p a , v 0 is a vertex in the rest pose, and w j is a joint weight that defines the contribution of joint j’s transformations to the current vertex.</Sentence> <DRI_Approach agreement="All_Equal">The weight w j can be assigned by the artist to control deformation and usually ∑ n j=1 joint (w j ) = 1.0.</DRI_Approach> <DRI_Background ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">This simple algorithm is used in many commercial graphics packages and real-time rendering applications but shows several limitations, because the deformation of this method is restricted to the subspace of the affine transformation of the joints [LCF00].</DRI_Background>
      
      
        <h1>3.2. Pose space deformation (PSD)</h1>
        <DRI_Approach agreement="All_Equal">If we have a sufficient set of examples to describe the movement of an articulated object, we can interpolate displacement in “pose space” [LCF00].</DRI_Approach> <DRI_Approach agreement="All_Equal">Each sample pose consists of sample skin geometry and the related joint skeleton, and a vector containing the joint angles represents the pose.</DRI_Approach> <Sentence agreement="All_Equal">If we translate each skinning sample k to the rest coordinate frame using inverse SSD, the displacement between the
        (c)
        (f)
        sample vertex v k and the rest pose vertex can be calculated: n joint</Sentence>
        
          3
          d k = ( ∑ w j T j ) −1 v k − v 0 j=1
        
        <Sentence agreement="All_Equal">where v k is a vertex in sample pose p k and d k is the displacement of this vertex relative to v 0 in the sample pose p k ; the other variables are defined as in equation 2.</Sentence> <DRI_Approach agreement="All_Equal">Note that the inverse here is of the weighted sum of affine transforms.</DRI_Approach> <DRI_Approach agreement="All_Equal">After defining the displacement of each pose, the displacement at an arbitrary pose can be calculated by RBF (Radial Basis Function) [LCF00] or normalized radial basis function [KM04] interpolation of the example poses’ displacements.</DRI_Approach> <Sentence agreement="All_Equal">The displacement d a of a vertex in an arbitrary pose p a can be calculated as n pose</Sentence>
        
          4
          d a = D(p a ) = ∑ r k (p a )d k k=1
        
        <Sentence agreement="All_Equal">where n pose is the number of sample poses, d a is a displacement of the vertex in an arbitrary pose p a , and the weight r k (p a ) defines the contribution of each sample pose.</Sentence> <Sentence agreement="All_Equal">Normalized Radial Basis Functions can smoothly interpolate pose space using: n pose</Sentence>
        
          5
          f t (p a ) = ∑ λ t,k φ k (γ k ) k=1
        
        <Sentence agreement="All_Equal">where f t (p a ) is the radial basis weight function for example t evaluated at an arbitrary pose p a , n pose is the number of sample poses, λ t,k are real valued weights between pose t and k, φ k are the radial basis functions, and γ k is the distance between the pose p k and the arbitrary pose p a (defined as the Euclidian distance between the joint vectors of each pose).</Sentence> <DRI_Approach agreement="All_Equal">The weight r k (p a ) is calculated using normalized RBFs and is used in equation 4 to calculate the displacement d a of a vertex in an arbitrary pose p a :</DRI_Approach>
        c The Eurographics Association and Blackwell Publishing 2006.
        T. Rhee, J.P. Lewis, and U. Neumann / EG 2006
        
          6
          r k (p a ) = ∑ n pose f k (p f a (p ) )
        
        <Sentence ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="Sentence">t=1 Gaussian radial basis functions φ k (γ k ) = exp( −γ 2σ 2 k 2 ) are one possible choice of the basis and the constant σ can be specified experimentally [LCF00].</Sentence>
      
      
        <h1>3.3. Weighted pose space deformation (WPSD)</h1>
        <DRI_Background agreement="All_Equal">WPSD is developed by Kurihara et al. [KM04] to deform their example-based human hand model derived from medical images.</DRI_Background> <Sentence ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="Sentence">In the original PSD, the distance between two poses p a and p k having n joint number of joints for each pose is defined as n joint</Sentence>
        
          7
          γ k (p a , p k ) = ∑ (p a, j − p k, j ) 2 j=1
        
        <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">In equation 7, since the γ k is the difference of n joint dimensional joint vectors of related poses, every vertex in the pose p k has same distance γ k resulting in the same weight r k (p a ) in every vertex of the pose p k .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">Furthermore, because each element of the joint vector equally contributes to the distance calculation, two vectors having a same value but different order generate same pose distance.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">For example, three different joint vectors p 1 = (θ, 0, 0), p 2 = (0, θ, 0), p 3 = (0, 0, θ) have same distance between them and it can cause unexpected results in PSD.</DRI_Approach> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="Sentence">In WPSD [KM04], Kurihara et al. modify the distance definition between poses using joint weight of each vertex i to give proper weight to each element of a joint vector,</DRI_Background>
        
          8
          n joint γ i,k (p a , p k ) = ∑ w i, j (p a, j − p k, j ) 2 j=1
        
        <Sentence agreement="All_Equal">where γ i,k (p a , p k ) is the distance between pose p a and p k of vertex i, and w i, j is weight of joint j of vertex i used in equation 2.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">From this definition, a more accurate pose distance is obtained and it generates better skinning in arbitrary poses, especially when the poses are far from the examples.</DRI_Approach> <DRI_Unspecified agreement="All_Equal">Figure 1 shows result of three different skinning methods, but we entrust the detail comparison between quality of each algorithm to their original papers [MTLT88,LCF00,KM04].</DRI_Unspecified>
      
      
        <h1>4. Computing joint weights from samples</h1>
        <DRI_Background agreement="All_Equal">The joint weights of each vertex are important to generate accurate skinning in SSD (equation 2) as well as in WPSD (equation 8).</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">In many applications, the weights are manually generated by skilled artists and it is hard to generate accurate values when a number of joints are involved in deforming a region.</DRI_Background> <DRI_Approach agreement="All_Equal">In this paper, we automatically calculate the joint weights of each vertex from the sample poses to enhance the accuracy of the weight value.</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">This results in better skinning and reduces the elaborate manual work required to create weight maps.</DRI_Outcome> <Sentence agreement="All_Equal">In each sample pose p k , we have following equation based on SSD: n joint</Sentence>
        
          9
          v  ̃ k − e k = ( ∑ w j T j )v 0 j=1
        
        <Sentence agreement="All_Equal">where v  ̃ k is a particular vertex from skin sample k, the right hand side is the SSD deformation of vertex v 0 from the rest pose, e k is a displacement between the SSD deformation and v  ̃ k , and the other variables are as in equation 2.</Sentence> <Sentence agreement="All_Equal">If we have sufficient examples involving the same set of n joint joints, we have n pose equations of the form: n joint</Sentence>
        
          10
          v  ̃ k − e k = ( ∑ v j w j ) j=1
        
        <Sentence agreement="All_Equal">where v j is v 0 transformed by T j .</Sentence> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">Although the e k is unknown, we can solve for weights that minimize the e k in a least squares sense by stacking the equations 10 (with e k omitted) into a linear matrix system</Sentence>
        
          11
          2 v − Aw
        
        <Sentence agreement="All_Equal">where w is a n joint -dimensional weight vector, v is a 3n pose dimensional vector containing the vertex v  ̃ i from every sample, and A is a 3n pose ×n joint matrix .</Sentence> <DRI_Approach agreement="All_Equal">&gt;From equation 11, we can calculate w from the given value of v and A to reduce the error of this equation.</DRI_Approach> <DRI_Approach agreement="All_Equal">We use the non-negative least square (NNLS) method to solve this problem and it determines positive weight values minimizing error in equation 10.</DRI_Approach> <DRI_Approach agreement="All_Equal">The calculated weight vector w is normalized to satisfy ∑ n j=1 joint w j = 1.0.</DRI_Approach> <DRI_Approach agreement="All_Equal">In order to avoid a singular matrix A, the number of poses should be greater or equal to the number of overall DOF (Degree Of Freedom) of the joint vector (each joint has 3 DOF), and the sample poses should be sufficiently different.</DRI_Approach> <DRI_Approach ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">James et al. used a similar approach to estimate vertex weights in each joint [JT05] and we demonstrate their efforts in our skinning method.</DRI_Approach>
      
      
        <h1>5. Parallel deformation on GPU</h1>
        <DRI_Background agreement="All_Equal">Skinning deformations vary across vertices.</DRI_Background> <DRI_Background agreement="All_Equal">In SSD and WPSD, this per-vertex computation is independent for each vertex and can be parallelized by a SIMD parallel architecture.</DRI_Background> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">We developed a parallel skinning algorithm for SSD and WPSD that is suitable to GPUs having a SIMD architecture with one-side communication to texture memory.</DRI_Outcome>
        c The Eurographics Association and Blackwell Publishing 2006.
        T. Rhee, J.P. Lewis, and U. Neumann / EG 2006
      
      
        <h1>5.1. Parallel WPSD</h1>
        <DRI_Approach agreement="All_Equal">The computation cost of the SSD skinning algorithm is O(n vertex × n joint ) from equations 1, 2, PSD is O(n vertex × n joint × n pose ) from equations 1, 2, 4, and WPSD is O(n vertex × n joint × n pose × n pose × n pose ) from equations 1, 2, 4, 5, 6.</DRI_Approach> <DRI_Approach agreement="All_Equal">Where, computation cost of original PSD is defined by equation 1, 2, 4, since r i is same in all vertices and d i can be pre-calculated.</DRI_Approach> <DRI_Approach agreement="All_Equal">The number of joints n joint and poses n pose can be reduced to the smaller numbers using the method developed by Kry et al. [KJP02], as will be discussed in section 5.2.1 with efforts to reduce texture memory space.</DRI_Approach> <DRI_Background agreement="All_Equal">In previous research, the Eigenskin method based on PSD was developed using GPU vertex programming [KJP02].</DRI_Background> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">The vertex program uses a relatively small number of slow processing units compared with the fragment processors, and the per-vertex computation cost of the original PSD is O(n joint × n pose ).</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Therefore WPSD, having higher pervertex computation cost O(n joint × n pose × n pose × n pose ), can clearly benefit from parallel computation on fragment processors.</DRI_Outcome>
      
      
        <h1>5.2. Parallel WPSD on GPU</h1>
        <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">We developed parallel skinning using the GPU fragment processors and demonstrate our method using three rendering passes.</DRI_Approach> <DRI_Approach agreement="All_Equal">In order to minimize real-time computation, we separate possible pre-calculation steps and save the results into texture memory using texture maps.</DRI_Approach> <DRI_Approach agreement="All_Equal">Because the value in the texture memory is not changed in the successive deformation, it can be pre-computed and stored in the read-only texture memory.</DRI_Approach> <DRI_Approach agreement="All_Equal">In the first and second pass, per-vertex deformation is calculated in the fragment program and the results are stored in texture maps using the FBO (Frame Buffer Object) extension [Gre05].</DRI_Approach> <DRI_Approach agreement="All_Equal">These texture maps are bound to the geometry of the rest pose with their texture coordinates.</DRI_Approach> <DRI_Approach agreement="All_Equal">In the third pass, each vertex in the rest pose is changed by the deformed vertex stored in the output texture generated in the first and second passes using vertex texture fetch.</DRI_Approach>
      
      
        <h1>5.2.1. Packing data into textures</h1>
        <DRI_Background ann2="DRI_Approach" agreement="3diff" ann1="DRI_Background" ann3="DRI_Challenge">The fragment processors cannot access vertex information.</DRI_Background> <DRI_Approach agreement="All_Equal">Instead, we can use texture memory to send data to the fragment program.</DRI_Approach> <DRI_Approach agreement="All_Equal">Information needed in the fragment program is packed into texture maps and stored into texture memory.</DRI_Approach> <DRI_Approach agreement="All_Equal">Geometry information from the rest pose is stored into two RGB texture maps, a vertex texture T v and normal texture T n ; each has size n vertex × 3.</DRI_Approach> <DRI_Approach agreement="All_Equal">These textures represent parameter v 0 in equation 2 and each 3D element (x, y, z) is stored into the (r, g, b) value of a texel [ Figure 2 ].</DRI_Approach> <Sentence agreement="All_Equal">The joint weights calculated in section 4 are also stored</Sentence>
        
          
          Figure 2: Packing data into textures: texture map T i can be
        
        <Sentence agreement="All_Equal">T v , T n , T w1 , T w2 , and T d j .</Sentence> <Sentence ann2="DRI_Approach" agreement="3diff" ann1="Sentence" ann3="DRI_Unspecified">V(vertex), N(normal), W(weight), J(joint index), and D(displacement) represent each texel (RGB(A)) value of the related texture.</Sentence> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">T d consist of eight T d j storing displacements of each pose j.</Sentence>
        <Sentence agreement="All_Equal">in the texture maps.</Sentence> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Outcome">In general, the distribution of skinning effects in an articulated body is local to several joints [MMT97,KJP02], even in a region as complicated as a hand.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Outcome">For example, deformations arising from the PIP (Proximal Interphalangeal) joint of index finger do not propagate to the other fingers, and deformation on the middle phalanx of index finger is only affected by the movement of PIP and DIP(Distal phalanx) joints.</DRI_Background> <DRI_Approach agreement="All_Equal">From this observation, we can reduce joint weight storage from the actual number of joint n joint to a smaller number of “principal joints” n  ̃ joint selected by sorting on the weight value.</DRI_Approach> <DRI_Approach agreement="All_Equal">We threshold n  ̃ joint at four in our tests with an additional four elements to hold the related joint index.</DRI_Approach> <DRI_Approach agreement="All_Equal">As a result, we can save the joint weights of entire geometry in two RGBA textures T w1 , T w2 each with size n vertex × 4(rgba) and store the entire information required for SSD [equation 2] in four textures T v , T n , T w1 , and T w2 .</DRI_Approach> <DRI_Approach agreement="All_Equal">The displacement values calculated by equation 3 can be stored in n pose displacement textures; n pose is the number of sample poses.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge">In case of complex joint structures and a large DOF model, we need many sample poses to calculate accurate joint weights and PSD deformation.</DRI_Approach> <DRI_Approach agreement="All_Equal">However, since the joint weights can be pre-calculated, we can reduce the number of sample poses needed in real-time PSD computation.</DRI_Approach> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">PCA (Principal Component Analysis) of pose space can yield an orthogonal basis called “ Eigendisplacement ” [KJP02].</DRI_Background> <DRI_Approach agreement="All_Equal">If we reduce the size of pose space from n pose to n  ̃ pose “principal poses” ( n  ̃ pose &lt; n pose ), we can reduce the number of displacement textures.</DRI_Approach> <DRI_Approach agreement="All_Equal">In our paper, we set n  ̃ pose as eight in our experiment and save displacements of all poses into a RGB texture T d having size n vertex × 8( n  ̃ pose ) × 3(rgb).</DRI_Approach> <DRI_Approach agreement="All_Equal">Therefore, from the two important observations of “principal joints” and “principal poses”, the original computation cost for SSD, PSD, and WPSD discussed in section 5.1 can be reduced using n  ̃ joint and n  ̃ pose rather than n joint and n pose .</DRI_Approach> <DRI_Approach agreement="All_Equal">In the original PSD, since the weight r i in equation 4 is the same at every vertex, we do not need to calculate this value in the GPU.</DRI_Approach> <DRI_Approach agreement="All_Equal">Since the size of this value is just n  ̃ pose , we can simply pass them to the GPU as parameters without generating a texture map.</DRI_Approach> <DRI_Approach agreement="All_Equal">Therefore, we store all the information needed to calculate the original PSD at this point.</DRI_Approach> <DRI_Approach agreement="All_Equal">In order to reduce real-time computation, we pre-calculate T j in equation 2 and λ in equation 5 and store them into another one channel texture T x having size n  ̃ pose × ( n  ̃ pose + n  ̃ joint × 3(x, y, z)).</DRI_Approach> <DRI_Approach agreement="All_Equal">As a result, we store all the variables required to calculate WPSD, PSD, and SSD in six texture maps: T v , T n , T w1 , T w2 , T d , and T x .</DRI_Approach> <DRI_Approach agreement="All_Equal">The values in the texture maps are stored in the texture memory at setup time, since they are not changed during the deformation process.</DRI_Approach> <DRI_Background ann2="DRI_Approach" agreement="3diff" ann1="DRI_Background" ann3="DRI_Outcome">In current graphic card architectures, data transfer from CPU to GPU is slow compared with memory access within the GPU.</DRI_Background> <Sentence ann2="DRI_Approach" agreement="3diff" ann1="Sentence" ann3="DRI_Outcome">Since the only data changed in each deformation and passed from CPU to GPU is a joint vector p a (size = n joint ) representing the current arbitrary pose, the memory access rate in our method is very efficient; In the original PSD method, an additional r k value (size = n  ̃ pose ) is required.</Sentence>
        c The Eurographics Association and Blackwell Publishing 2006.
        T. Rhee, J.P. Lewis, and U. Neumann / EG 2006
      
      
        <h1>5.2.2. Configurations for fragment program</h1>
        <Sentence agreement="All_Equal">Variables: T out = output texture, T v = vertex texture 1 /* Set orthographic camera with same size of quad */; 2 gluOrtho2D(-1, 1, -1, 1); 3 bind(FBO); 4 /* Bind T out and set to FBO drawbuffer */; 5 bind(T out ), SetFBOdrawbuffer(T out ); 6 bind(T v ); 7 enable(fragment program); 8 /* Set viewport to the resolution of the texture */; 9 glViewport(0, 0, texWidth, texHeight); 10 /* Render a quad into T out using FBO */; 11 glBegin(GL_QUADS); 12 { glTexCoord2f(0, 0); glVertex3f(-1, -1, -0.5f); 13 glTexCoord2f(1, 0); glVertex3f( 1, -1, -0.5f); 14 glTexCoord2f(1, 1); glVertex3f( 1, 1, -0.5f); 15 glTexCoord2f(0, 1); glVertex3f(-1, 1, -0.5f); 16 }; 17 disable(fragment program); Algorithm 1: Configuration of fragment program for vertex refering and direct rendering into texture
        Since vertex information cannot be accessed by the fragment program, vertex deformation on a GPU is usually performed by a vertex program [KJP02, BK05].</Sentence> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Although, we cannot access vertex data in the fragment program, the efficiency of parallel computation on a fragment program is higher, since the fragment processor has more processing units and each of them has more computation power than a vertex processor.</DRI_Outcome> <DRI_Approach agreement="All_Equal">The fragment processing system is a general SIMD architecture using fragment streams as input data; each fragment is assigned to a fragment processor to calculate its final color value independently and in parallel.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Approach">We developed a parallel WPSD algorithms using the fragment processors to enhance the extent of parallel computation.</DRI_Approach> <DRI_Approach agreement="All_Equal">Geometry information like vertex positions and normals are stored in texture maps T v and T n as described in section 5.2.1 and the vertex information is referred in the fragment processors to calculate final color values.</DRI_Approach> <DRI_Approach agreement="All_Equal">In order to assign each vertex value stored in a texture map to a fragment, we bind the geometry texture T v or T n to a quad and render it using an orthographic camera having the same width and height as the quad.</DRI_Approach> <DRI_Approach agreement="All_Equal">Furthermore, since the viewport is set to the same resolution as the textures, each fragment is exactly matched with each texel holding the vertex information, and we can access each vertex using the texture coordinates of the fragment; vertex weights and displacements stored in the texture maps can also be accessed by similar methods.</DRI_Approach> <DRI_Background agreement="All_Equal">A similar idea was developed in [PBMH02] to calculate ray tracing in a fragment program and is used in GPGPU (General Purpose computation on GPUs) applications [GPG, LHK ∗ 04, PF05].</DRI_Background> <DRI_Background agreement="All_Equal">The FBO (Frame Buffer Object) extension [Gre05] supports rendering into an attached texture.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Outcome">This saves memory and time, since there is no copy operation from frame buffer to texture buffer.</DRI_Background> <DRI_Approach agreement="All_Equal">We implemented our WPSD algorithm using the fragment program with the FBO extension to store the result directly into texture maps accessed by vertex program in the next pass.</DRI_Approach> <DRI_Unspecified agreement="All_Equal">A summary of this method is shown in Algorithm 1.</DRI_Unspecified>
      
      
        <h1>5.3. GPU implementation</h1>
        <DRI_Approach agreement="All_Equal">We implemented GPU deformation using three rendering passes, and the basic architecture is described in figure 3 .</DRI_Approach> <DRI_Approach agreement="All_Equal">In the first pass, we parallelize per-vertex deformation using GPU fragment processors.</DRI_Approach> <DRI_Approach agreement="All_Equal">The data required to calculate this deformation is stored in the textures as described in section 5.2.1 and the deformation for each vertex is calculated in a fragment processor.</DRI_Approach> <DRI_Approach agreement="All_Equal">In a given arbitrary pose defined by a joint vector, SSD is computed by equation 2 using texture maps T v , T w1 , T w2 and T x ; refer to the texture map notation in section 5.2.1.</DRI_Approach> <DRI_Approach agreement="All_Equal">PSD is computed by equation 4 using T d , T x , after calculating r k (p a ) by equation 6.</DRI_Approach> In the case of WPSD, the weighted distance is computed by equation 8 using T w1 , T w2 , and T x . <Sentence agreement="All_Equal">In the first pass, the result of the deformation is rendered</Sentence>
        c The Eurographics Association and Blackwell Publishing 2006.
        T. Rhee, J.P. Lewis, and U. Neumann / EG 2006
        
          
          Figure 3: Overview of WPSD on GPU: Each T i is the texture
        
        <Sentence agreement="All_Equal">map storing the required data for the calculation (refer to section 5.2.1 for their values) , T i ′ s are the texture maps to store the output of the 1st and 2nd passes, P 0 is the geometry in the rest pose, and P a is a deformed model in an arbitrary pose.</Sentence>
        <Sentence agreement="All_Equal">into a texture map T v ′ , using the FBO, and passed to the third pass.</Sentence> <DRI_Approach agreement="All_Equal">In the second pass we calculate and store normal deformation with a similar method as in the first pass, and the results are stored in the texture map T n ′ .</DRI_Approach> <DRI_Approach agreement="All_Equal">In the third pass, using a vertex program, each vertex of the rest pose is transformed to the final deformed position using the information from the texture maps computed in the previous two passes.</DRI_Approach> <DRI_Approach agreement="All_Equal">In order to access related texture information in each vertex, we created texture coordinates of each texel in pre-processing and used them in the vertex program.</DRI_Approach> <DRI_Approach agreement="All_Equal">Specifically, the two texture maps, T v ′ and T n ′ that are generated in the first and second passes are accessed in the vertex program using the texture coordinate of the current vertex.</DRI_Approach> <DRI_Approach agreement="All_Equal">Alternatively, multiple render targets (MRTs) can combine the first and second pass, and vertex buffer objects (VBOs) could be used to render the deformed results back to the vertex array [OPE, GPG, LHK ∗ 04].</DRI_Approach>
      
      
        <h1>6. Results</h1>
        <DRI_Approach agreement="All_Equal">We tested our methods using upper arm models consisting of four joints (collar, shoulder, elbow, and wrist).</DRI_Approach> <DRI_Approach agreement="All_Equal">Each has three DOF and the wrist is the end joint having no DOF.</DRI_Approach> <DRI_Approach agreement="All_Equal">Three different resolution meshes are used to test the performance of GPU parallel computation: the high-resolution model has 91460 triangles with 46036 vertices, the midresolution model has 22836 triangles with 11574 vertices, and the low-resolution model has 5762 triangles with 2972 vertices [ Figure 4 ].</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Note that these models are considerably more detailed than those used in current games, so the reported frame rates would be much higher if typical gameresolution models were used.</DRI_Approach> <DRI_Outcome agreement="All_Equal">On the other hand, with the expected growth of GPU processing power, models such as these will be in wide use in a few years, and algorithms such as WPSD will be required to produce realistic deformations at this level of resolution.</DRI_Outcome> <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">Eight sample poses were created by Poser [Cur] and the joints weights and displacements of each sample were derived from these models [ Figure 5 ].</DRI_Approach> <DRI_Approach agreement="All_Equal">Our parallel algorithm is based on three pass GPU computation.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome_Contribution">The fragment program for the 1st and 2nd pass, and the vertex program for the 3rd pass are implemented in the Cg language [FK03].</DRI_Approach> <DRI_Approach agreement="All_Equal">For accuracy the GPU computation is performed by 32bit floating point operations with 32bit floating point texture maps.</DRI_Approach> <DRI_Unspecified agreement="All_Equal">Table 2 shows the total memory space to store texture maps required by the fragment program.</DRI_Unspecified> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Note that the maximum required memory space for the highest resolution model is just 6.8 Mbytes; the size of the output texture T v ′ and T n ′ is the same as the size of T v and T n .</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">The results of GPU-based deformation for SSD, PSD, and WPSD are shown in Figure 1 and 6, and the experiment is performed in a GeForce 6800 Ultra GPU and a 3.4Ghz Pentium 4 CPU.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">The timing results of each algorithm on the CPU and GPU are summarized in table 1 .</DRI_Outcome> <DRI_Outcome agreement="All_Equal">On average, our GPU-based deformation shows around 20 times speed-up compared with CPU-based deformation.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">GPU-based WPSD has roughly the same speed as CPUbased SSD.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Therefore, real-time applications using SSD can substitute WPSD running on the GPU without loosing their real-time performance.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">Since our algorithm shows speed-up for SSD and PSD as well as WPSD, applications can choose the most appropriate skinning method according to the required deformation and detail.</DRI_Outcome>
        
          
          Figure 4: Mesh of test data: the top row is a low-resolution mesh, the second row is a mid-resolution mesh, and the bottom row is a high-resolution mesh
        
        c The Eurographics Association and Blackwell Publishing 2006.
        T. Rhee, J.P. Lewis, and U. Neumann / EG 2006
        
          
            
              
                
                   Method
                   Mesh
                   CPU(FPS)
                   GPU(FPS)
                
              
              
                
                   SSD
                   low
                   150
                   1425
                
                
                  
                   middle
                   39
                   630
                
                
                  
                   high
                   5
                   164
                
                
                   PSD
                   low
                   98
                   1230
                
                
                  
                   middle
                   23
                   530
                
                
                  
                   high
                   4.5
                   140
                
                
                   WPSD
                   low
                   5
                   85
                
                
                  
                   middle
                   1.2
                   25
                
                
                  
                   high
                   0.29
                   7
                
              
            
          
          Method Mesh CPU(FPS) GPU(FPS) SSD low 150 1425 middle 39 630 high 5 164 PSD low 98 1230 middle 23 530 high 4.5 140 WPSD low 5 85 middle 1.2 25 high 0.29 7
          Table 1: Timing results (in FPS) of each algorithm: the lowresolution mesh has 5762 triangles with 2972 vertices, the mid-resolution mesh has 22836 triangles with 11574 vertices, and the high-resolution mesh has 91460 triangles with 46036 vertices.
        
        
          
            
              
                
                   Vertices
                   T v &amp;T n
                   T w1 &amp;T w2
                   T d
                   T x
                   Tot
                
              
              
                
                   2972 (low)
                   35×2
                   46×2
                   278
                   1
                   441
                
                
                   11574 (mid)
                   135×2
                   180×2
                   1080
                   1
                   1711
                
                
                   46036 (high)
                   539×2
                   719×2
                   4315
                   1
                   6832
                
              
            
          
          Vertices T v &amp;T n T w1 &amp;T w2 T d T x Tot 2972 (low) 35×2 46×2 278 1 441 11574 (mid) 135×2 180×2 1080 1 1711 46036 (high) 539×2 719×2 4315 1 6832
          Table 2: Texture memory to store data required in fragment program (in Kbytes); refer to section 5.2.1 for texture notation .
        
      
      
        <h1>7. Conclusions</h1>
        <DRI_Outcome_Contribution ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">In this paper, we present a parallel skinning algorithm suitable for SIMD architectures such as GPUs.</DRI_Outcome_Contribution> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">The joint weights of each vertex are automatically computed by NNLS and used in the skinning computation for SSD and WPSD.</DRI_Approach> <DRI_Approach agreement="All_Equal">Independent per-vertex deformation is parallelized on the GPU using three rendering passes.</DRI_Approach> <DRI_Approach agreement="All_Equal">In the first and second passes, per-vertex deformation is calculated by the fragment processors and the results are stored in texture maps using FBO.</DRI_Approach> <DRI_Approach agreement="All_Equal">In the third pass, using vertex processors, each vertex of the rest pose is changed by the deformed vertex stored in the textures generated by the first and second passes.</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome">Articulated body skinning using SSD, PSD, and WPSD are efficiently parallelized by our GPU-based method, and on a detailed model, we obtain around 20 times speed-up compared with CPU-based computation.</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">Principal component compression of the examples and careful analysis of joint distributions can reduce the domain of computation [KJP02] and other algorithms based on the SSD, PSD, and shape interpolation may be parallelized on GPU using our approach.</DRI_Outcome_Contribution>
        
          
          Figure 6: Arbitrary poses deformed by WPSD on GPU
        
      
      
        <h1>Acknowledgments</h1>
        <DRI_Unspecified agreement="All_Equal">This research has been funded by the Integrated Media System Center/USC, and Samsung Electronics.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">We wish to thank KyungKook Park, Changki Min, and Tim Foley for discussions about GPUs, and the anonymous reviewers for their sincere comments.</DRI_Unspecified>
      
      
        <h1>References</h1>
                
          [ACP02] ALLEN B., CURLESS B., POPOVI  ́ c; Z.: Articulated body deformation from range scan data. In SIG-GRAPH ’02: Proceedings of the 29th annual conference on Computer graphics and interactive techniques (New York, NY, USA, 2002), ACM Press, pp.
          612–619.
          [AHS03] ALBRECHT I., HABER J., SEIDEL H. P.: Construction and animation of anatomically based human hand models. In Proceedings of the 2003 ACM SIGGRAPH/Eurographics Symposium on Computer Animation (SCA-03) (2003), pp. 98–109.
          [ASK05] ANGUELOV D., SRINIVASAN P., KOLLER D., THRUN S., RODGERS J., DAVIS J.: Scape: shape completion and animation of people. ACM Trans. Graph. 24, 3 (2005), 408–416.
          [BK05] BOTSCH M., KOBBELT L.: Real-time shape editing using radial basis functions. Computer Graphics Forum 24, 3 (2005), 611–621. (Proceedings of Eurographics 2005).
          [CBC05] CAPELL S., BURKHART M., CURLESS B., DUCHAMP T., POPOVI  ́ c; Z.: Physically based rigging for deformable characters. In SCA ’05: Proceedings of the 2005 ACM SIGGRAPH/Eurographics symposium on Computer animation (New York, NY, USA, 2005), ACM Press, pp. 301–310. [Cur] CURIOUSLAB: Poser 6. http://www.curiouslabs.com .
          [FK03] FERNANDO R., KILGARD M. J.: The Cg Tutorial; The Definitive Guide to Programmable Real-Time Graphics. Addison-Wesley, 2003. [GPG] GPGPU: General-purpose computation using graphics hardware. http://gpgpu.org .
          [Gre05] GREEN S.: The OpenGL Framebuffer Object Extension. Game Developers Conference, 2005. http://developer.nvidia.com/object/gdc_2005_ presentations.html.
          [JP02] JAMES D. L., PAI D. K.: Dyrt: dynamic response textures for real time deformation simulation with graphics hardware. In SIGGRAPH ’02: Proceedings of the 29 th annual conference on Computer graphics and interactive techniques (New York, NY, USA, 2002), ACMPress, pp. 582–585.
          [JT05] JAMES D. L., TWIGG C. D.: Skinning mesh animations. ACM Trans. Graph. 24, 3 (2005), 399–407.
          [KJP02] KRY P. G., JAMES D. L., PAI D. K.: Eigen Skin: Real time large deformation character skinning in hardware. In Proceedings of the 2002 ACM SIGGRAPH Symposium on Computer Animation (SCA-02) (2002), pp. 153–160.
          [KM04] KURIHARA T., MIYATA N.: Modeling deformable human hands from medical images. In Proceedings of the 2004 ACM SIGGRAPH Symposium on Computer Animation (SCA-04) (2004), pp. 357–366.
          [KZ05] KAVAN L., ZARA J.: Spherical blend skinning: A real-time deformation of articulated models. In 2005 ACMSIGGRAPH Symposium on Interactive 3D Graphics and Games (April 2005), ACM Press, pp. 9–16.
          [LCF00] LEWIS J. P., CORDNER M., FONG N.: Pose space deformation: a unified approach to shape interpolation and skeleton-driven deformation. In SIGGRAPH ’00: Proceedings of the 27th annual conference on Computer graphics and interactive techniques (New York, NY, USA, 2000), ACMPress/Addison-Wesley Publishing Co., pp. 165–172.
          [LHK04] LUEBKE D., HARRIS M., KRUGER J., PURCELLT., GOVINDARAJU N., BUCK I., WOOLLEY C., LEFOHN A.: Gpgpu: general purpose computation ongraphics hardware. In GRAPH ’04: Proceedings of the conference on SIGGRAPH 2004 course
          notes (New York, NY, USA, 2004), ACM Press, p. 33.
          [MMT97] MOCCOZET L., MAGNENAT-THALMANN N.: Dirichlet free-form deformations and their application to hand simulation. In Computer Animation (1997).
          [MTG03] MOHR A., TOKHEIM L., GLEICHER M.: Direct manipulation of interactive character skins. In SI3D ’03: Proceedings of the 2003 symposium on Interactive 3D graphics (New York, NY, USA, 2003), ACM Press, pp. 27–30.
          [MTLT88] MAGNENAT-THALMANN N., LAPERRIÈRE R., THALMANN D.: Joint dependent local deformations for hand animation and object grasping. In Graphics In terface ’88 (June 1988), pp. 26–33.
          [OPE] OPENGL: Opengl extension registry. http:// oss.sgi.com/projects/ogl sample/registry/.
          [PBMH02] PURCELL T. J., BUCK I., MARK W. R., HANRAHAN P.: Ray tracing on programmable graphics hardware. ACM Transactions on Graphics 21, 3 (July 2002), 703–
          712. ISSN 0730-0301 (Proceedings of ACM SIGGRAPH 2002).
          [PCLS05] PRATSCHER M., COLEMAN P., LASZLO J., SINGH K.: Outside-in anatomy based character rigging. In SCA ’05: Proceedings of the 2005 ACM SIGGRAPH/Eurographics symposium on Computer animation (New York, NY, USA, 2005), ACM Press, pp. 329–338.
          [PF05] PHARR M., FERNANDO R.: GPU Gems 2; Programming Techniques for HighPerformance Graphics and General-Purpose Computation. Addison-Wesley, 2005.
          [RNL06] RHEE T., NEUMANN U., LEWIS J.: Human hand modeling from surface anatomy. In I3DG ’06: Proc. of ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games (2006).
          [SNF05] SIFAKIS E., NEVEROV I., FEDKIW R.: Automatic determination of facial muscle activations from sparse motion capture marker data. ACM Trans. Graph. 24, 3 (2005), 417–425.
          [SRC01] SLOAN P.-P. J., ROSE C. F., COHEN M. F.: Shape by example. In SI3D ’01: Proceedings of the 2001 symposium on Interactive 3D graphics (New York, NY, USA, 2001), ACM Press, pp. 135–143.
          [Web00] WEBER J.: Run-time skin deformation. In Proceedings of Game Developers Conference (2000).
          [WP02] WANG X. C., PHILLIPS C.: Multi-weight enveloping: least-squares approximation techniques for skin animation. In SCA ’02: Proceedings of the 2002 ACM
          SIGGRAPH/Eurographics symposium on Computer animation (New York, NY, USA, 2002),
          ACM Press, pp. 129–138.
        
        
          
          Figure 5: Samples poses and displacements: the first row shows each sample poses, the second row shows displacement of each sample pose with the rest pose in the first column of the third row. Please enlarge to see details.
        
        c The Eurographics Association and Blackwell Publishing 2006.
      
    
  
</Document>