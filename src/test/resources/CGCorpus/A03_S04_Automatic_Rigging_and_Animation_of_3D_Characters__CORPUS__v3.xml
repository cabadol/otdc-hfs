<?xml version="1.0" encoding="UTF-8" ?>
<Document corpusVersion="3" name="A03_S04_Automatic_Rigging_and_Animation_of_3D_Characters">
  
    fd87711d862391a88b85056e94843d7018778c5c2c90e91a815bdd4b6973cc17
    3wwb
    http://dx.doi.org/10.1145/1275808.1276467
  
  
    
      To appear in the ACM SIGGRAPH conference proceedings
      
        <article-title>Automatic Rigging and Animation of 3D Characters</article-title>
      
      
        
          Ilya Baran ∗ Jovan Popović † Computer Science
        
        
          Artificial Intelligence Laboratory Massachusetts Institute of Technology
          †
        
      
      <Sentence agreement="All_Equal">∗ e-mail: ibaran@mit.edu † e-mail: jovan@csail.mit.edu
      Animating an articulated 3D character currently requires manual rigging to specify its internal skeletal structure and to define how the input motion deforms its surface.</Sentence> <DRI_Challenge_Goal ann2="DRI_Outcome_Contribution" agreement="3diff" ann1="DRI_Challenge_Goal" ann3="DRI_Approach">We present a method for animating characters automatically.</DRI_Challenge_Goal> <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">Given a static character mesh and a generic skeleton, our method adapts the skeleton to the character and attaches it to the surface, allowing skeletal motion data to animate the character.</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">Because a single skeleton can be used with a wide range of characters, our method, in conjunction with a library of motions for a few skeletons, enables a user-friendly animation system for novices and children.</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">Our prototype implementation, called Pinocchio, typically takes under a minute to rig a character on a modern midrange PC.</DRI_Outcome_Contribution>
	<h2>CR Categories: </h2>I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism—Animation Keywords: Animation, Deformations, Geometric Modeling <h2>Keywords: </h2>Animation, Deformations, Geometric Modeling
    
    
      
        <h1>1 Introduction</h1>
      
      <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Modeling in 3D is becoming much easier than before.</DRI_Background> <DRI_Background agreement="All_Equal">User-friendly systems such as Teddy [Igarashi et al. 1999] and Cosmic Blobs ( http://www.cosmicblobs.com/) have made the creation of 3D characters accessible to novices and children.</DRI_Background> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">Bringing these static shapes to life, however, is still not easy.</DRI_Challenge> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">In a conventional skeletal animation package, the user must rig the character manually.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">This requires placing the skeleton joints inside the character and specifying which parts of the surface are attached to which bone.</DRI_Background> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">The tedium of this process makes simple character animation more difficult than it could be.</DRI_Challenge> <DRI_Challenge_Goal agreement="All_Equal">We envision a system that eliminates this tedium to make animation more accessible for children, educators, researchers, and other non-expert animators.</DRI_Challenge_Goal> <DRI_Challenge ann2="DRI_Outcome" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_Challenge_Goal">For example, a child should be able to model a unicorn, click the “Quadruped Gallop” button, and watch the unicorn start galloping.</DRI_Challenge> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">To support this functionality, we need a method (as shown in Figure 1 ) that takes a character, a skeleton, and a motion of that skeleton as input, and outputs the moving character.</DRI_Approach> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">The missing portion is the rigging: motion transfer has been addressed in prior work [Gleicher 2001].</DRI_Background> <DRI_Approach agreement="All_Equal">Our algorithm consists of two main steps: skeleton embedding and skin attachment.</DRI_Approach> <DRI_Approach agreement="All_Equal">Skeleton embedding computes the joint positions of the skeleton inside the character by minimizing a penalty function.</DRI_Approach> <DRI_Approach agreement="All_Equal">To make the optimization problem computationally feasible, we first embed the skeleton into a discretization of the character’s interior and then refine this embedding using continuous optimization.</DRI_Approach> <DRI_Approach agreement="All_Equal">The skin attachment is computed by assigning bone weights based on the proximity of the embedded bones smoothed by a diffusion equilibrium equation over the character’s surface.</DRI_Approach> <DRI_Approach agreement="All_Equal">Our design decisions relied on three criteria, which we also used to evaluate our system:</DRI_Approach>
      
        
        Figure 1: The automatic rigging method presented in this paper allowed us to implement an easy-to-use animation system, which we called Pinocchio. In this example, the triangle mesh of a jolly cartoon character is brought to life by embedding a skeleton inside it and applying a walking motion to the initially static shape.
      
      <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Outcome">• Generality: A single skeleton is applicable to a wide variety of characters: for example, our method can use a generic biped skeleton to rig an anatomically correct human model, an anthropomorphic robot, and even something that has very little resemblance to a human.</Sentence> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Outcome">• Quality: The resulting animation quality is comparable to that of modern video games.</Sentence> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Outcome">• Performance: The automatic rigging usually takes under one minute on an everyday PC.</Sentence>
      <DRI_Challenge ann2="DRI_Approach" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_Challenge_Goal">A key design challenge is constructing a penalty function that penalizes undesirable embeddings and generalizes well to new characters.</DRI_Challenge> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge">For this, we designed a maximum-margin supervised learning method to combine a set of hand-constructed penalty functions.</DRI_Approach> <DRI_Approach agreement="All_Equal">To ensure an honest evaluation and avoid overfitting, we tested our algorithm on 16 characters that we did not see or use during development.</DRI_Approach> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Our algorithm computed a good rig for all but 3 of these characters.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">For each of the remaining cases, one joint placement hint corrected the problem.</DRI_Outcome> <DRI_Approach agreement="All_Equal">We simplify the problem by making the following assumptions.</DRI_Approach> <DRI_Approach agreement="All_Equal">The character mesh must be the boundary of a connected volume.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">The character must be given in approximately the same orientation and pose as the skeleton.</DRI_Approach> <DRI_Approach agreement="All_Equal">Lastly, the character must be proportioned roughly like the given skeleton.</DRI_Approach> <Sentence agreement="All_Equal">We introduce several new techniques to solve the automatic rigging problem: • A maximum-margin method for learning the weights of a linear combination of penalty functions based on examples, as an alternative to hand-tuning (Section 3.3).</Sentence> <DRI_Approach agreement="All_Equal">• An A ∗ -like heuristic to accelerate the search for an optimal skeleton embedding over an exponential search space (Section 3.4).</DRI_Approach> <DRI_Approach agreement="All_Equal">• Use of Laplace’s diffusion equation to generate weights for attaching mesh vertices to the skeleton using linear blend skinning (Section 4).</DRI_Approach> <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">This method could also be useful in existing 3D packages.</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">Our prototype system, called Pinocchio, rigs the given character using our algorithm.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">It then transfers a motion to the character using online motion retargetting [Choi and Ko 2000] to eliminate footskate by constraining the feet trajectories of the character to the feet trajectories of the given motion.</DRI_Outcome>
      1
      To appear in the ACM SIGGRAPH conference proceedings
      
        <h1>2 Related Work</h1>
        <Sentence agreement="All_Equal">Character Animation Most prior research in character animation, especially in 3D, has focused on professional animators; very little work is targeted at novice users.</Sentence> <DRI_Background agreement="All_Equal">Recent exceptions include Motion Doodles [Thorne et al. 2004] as well as the work of Igarashi et al. on spatial keyframing [2005b] and as-rigid-as-possible shape manipulation [2005a].</DRI_Background> <DRI_Background agreement="All_Equal">These approaches focus on simplifying animation control, rather than simplifying the definition of the articulation of the character.</DRI_Background> <DRI_Background agreement="All_Equal">In particular, a spatial keyframing system expects an articulated character as input, and as-rigid-as-possible shape manipulation, besides being 2D, relies on the constraints to provide articulation information.</DRI_Background> <DRI_Background agreement="All_Equal">The Motion Doodles system has the ability to infer the articulation of a 2D character, but their approach relies on very strong assumptions about how the character is presented.</DRI_Background> <Sentence agreement="All_Equal">Skeleton Extraction Although most skeleton-based prior work on automatic rigging focused on skeleton extraction, for our problem, we advocate skeleton embedding.</Sentence> <DRI_Background agreement="All_Equal">A few approaches to the skeleton extraction problem are representative.</DRI_Background> <DRI_Background agreement="All_Equal">Teichmann and Teller [1998] extract a skeleton by simplifying the Voronoi skeleton with a small amount of user assistance.</DRI_Background> <DRI_Background agreement="All_Equal">Liu et al. [2003] use repulsive force fields to find a skeleton.</DRI_Background> <DRI_Background agreement="All_Equal">In their paper, Katz and Tal [2003] describe a surface partitioning algorithm and suggest skeleton extraction as an application.</DRI_Background> <DRI_Background agreement="All_Equal">The technique in Wade [2000] is most similar to our own: like us, they approximate the medial surface by finding discontinuities in the distance field, but they use it to construct a skeleton tree.</DRI_Background> <DRI_Challenge ann2="DRI_Background" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_Challenge_Hypothesis">For the purpose of automatically animating a character, however, skeleton embedding is much more suitable than extraction.</DRI_Challenge> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">For example, the user may have motion data for a quadruped skeleton, but for a complicated quadruped character, the extracted skeleton is likely to have a different topology.</DRI_Challenge> <DRI_Background agreement="All_Equal">The anatomically appropriate skeleton generation by Wade [2000] ameliorates this problem by techniques such as identifying appendages and fitting appendage templates, but the overall topology of the resulting skeleton may still vary.</DRI_Background> <DRI_Background agreement="All_Equal">For example, for the character in Figure 1 , ears may be mistaken for arms.</DRI_Background> <DRI_Background agreement="All_Equal">Another advantage of embedding over extraction is that the given skeleton provides information about the expected structure of the character, which may be difficult to obtain from just the geometry.</DRI_Background> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">So although we could use an existing skeleton extraction algorithm and embed our skeleton into the extracted one, the results would likely be undesirable.</DRI_Challenge> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">For example, the legs of the character in Figure 1 would be too short if a skeleton extraction algorithm were used.</DRI_Challenge> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Background">Template Fitting Animating user-provided data by fitting a template has been successful in cases when the model is fairly similar to the template.</Sentence> <DRI_Background agreement="All_Equal">Most of the work has been focused on human models, making use of human anatomy specifics, e.g. [Moccozet et al. 2004].</DRI_Background> <DRI_Background agreement="All_Equal">For segmenting and animating simple 3D models of characters and inanimate objects, Anderson et al. [2000] fit voxel-based volumetric templates to the data.</DRI_Background> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Background">Skinning Almost any system for mesh deformation (whether surface based [Lipman et al. 2005; Yu et al. 2004] or volume based [Zhou et al. 2005]) can be adapted for skeleton-based deformation.</Sentence> <DRI_Background agreement="All_Equal">Teichmann and Teller [1998] propose a spring-based method.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Unfortunately, at present, these methods are unsuitable for real-time animation of even moderate size meshes.</DRI_Background> <DRI_Background agreement="All_Equal">Because of its simplicity and efficiency (and simple GPU implementation), and despite its quality shortcomings, linear blend skinning (LBS), also known as skeleton subspace deformation, remains the most popular method used in practice.</DRI_Background> <DRI_Background agreement="All_Equal">Most real-time skinning work, e.g. [Kry et al. 2002; Wang et al. 2007], has focused on improving on LBS by inferring the character articulation from multiple example meshes.</DRI_Background> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">However, such techniques are unsuitable for our problem because we only have a single mesh.</DRI_Challenge> <DRI_Challenge ann2="DRI_Challenge_Goal" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_Approach">Instead, we must infer articulation by using the given skeleton as an encoding of the likely modes of deformation, not just as an animation control structure.</DRI_Challenge> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">To our knowledge, the problem of finding bone weights for LBS from a single mesh and a skeleton has not been sufficiently addressed in the literature.</DRI_Challenge> <DRI_Background agreement="All_Equal">Previous methods are either mesh resolution dependent [Katz and Tal 2003] or the weights do not vary smoothly along the surface [Wade 2000], causing artifacts on highresolution meshes.</DRI_Background> <DRI_Background agreement="All_Equal">Some commercial packages use proprietary methods to assign default weights.</DRI_Background> <DRI_Background agreement="All_Equal">For example, Autodesk Maya 7 assigns weights based solely on the vertex proximity to the bone, ignoring the mesh structure, which results in serious artifacts when the mesh intersects the Voronoi diagram faces between logically distant bones.</DRI_Background>
      
      
        <h1>3 Skeleton Embedding</h1>
        <DRI_Background agreement="All_Equal">Skeleton embedding resizes and positions the given skeleton to fit inside the character.</DRI_Background> <DRI_Challenge ann2="DRI_Background" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_Approach">This can be formulated as an optimization problem: “compute the joint positions such that the resulting skeleton fits inside the character as nicely as possible and looks like the given skeleton as much as possible.</DRI_Challenge><DRI_Challenge ann2="DRI_Background" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_Approach">” For a skeleton with s joints (by “joints,” we mean vertices of the skeleton tree, including leaves), this is a 3s-dimensional problem with a complicated objective function.</DRI_Challenge> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">Solving such a problem directly using continuous optimization is infeasible.</DRI_Challenge> <DRI_Approach agreement="All_Equal">Pinocchio therefore discretizes the problem by constructing a graph whose vertices represent potential joint positions and whose edges are potential bone segments.</DRI_Approach> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge_Goal">This is challenging because the graph must have few vertices and edges, and yet capture all potential bone paths within the character.</DRI_Challenge> <DRI_Approach agreement="All_Equal">The graph is constructed by packing spheres centered on the approximate medial surface into the character and by connecting sphere centers with graph edges.</DRI_Approach> <DRI_Approach agreement="All_Equal">Pinocchio then finds the optimal embedding of the skeleton into this graph with respect to a discrete penalty function.</DRI_Approach> <DRI_Approach agreement="All_Equal">It uses the discrete solution as a starting point for continuous optimization.</DRI_Approach> <DRI_Approach agreement="All_Equal">To help with optimization, the given skeleton can have a little extra information in the form of joint attributes: for example, joints that should be approximately symmetric should be marked as such; also some joints can be marked as “feet,” indicating that they should be placed near the bottom of the character.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">We describe the attributes Pinocchio uses in a supplemental document[Baran and Popović 2007a].</DRI_Approach> <DRI_Approach agreement="All_Equal">These attributes are specific to the skeleton but are independent of the character shape and do not reduce the generality of the skeletons.</DRI_Approach>
        2
        To appear in the ACM SIGGRAPH conference proceedings
        
          
          
          Figure 2: Approximate Medial Sur-
        
        
          Figure 3: Packed Spheres
        
        face
        
          <h2>3.1 Discretization</h2>
          <DRI_Approach agreement="All_Equal">Before any other computation, Pinocchio rescales the character to fit inside an axis-aligned unit cube.</DRI_Approach> <DRI_Approach agreement="All_Equal">As a result, all of the tolerances are relative to the size of the character.</DRI_Approach> <Sentence agreement="All_Equal">Distance Field To approximate the medial surface and to facilitate other computations, Pinocchio computes a trilinearly interpolated adaptively sampled signed distance field on an octree [Frisken et al. 2000].</Sentence> <DRI_Approach agreement="All_Equal">It constructs a kd-tree to evaluate the exact signed distance to the surface from an arbitrary point.</DRI_Approach> <DRI_Approach agreement="All_Equal">It then constructs the distance field from the top down, starting with a single octree cell and splitting a cell until the exact distance is within a tolerance τ of the interpolated distance.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">We found that τ = 0.003 provides a good compromise between accuracy and efficiency for our purposes.</DRI_Approach> <DRI_Approach agreement="All_Equal">Because only negative distances (i.e. from points inside the character) are important, Pinocchio does not split cells that are guaranteed not to intersect the character’s interior.</DRI_Approach> <Sentence agreement="All_Equal">Approximate Medial Surface Pinocchio uses the adaptive distance field to compute a sample of points approximately on the medial surface ( Figure 2 ).</Sentence> <DRI_Approach agreement="All_Equal">The medial surface is the set of C 1 discontinuities of the distance field.</DRI_Approach> <DRI_Approach agreement="All_Equal">Within a single cell of our octree, the interpolated distance field is guaranteed to be C 1 , so it is necessary to look at only the cell boundaries.</DRI_Approach> <DRI_Approach agreement="All_Equal">Pinocchio therefore traverses the octree and for each cell, looks at a grid (of spacing τ ) of points on each face of the cell.</DRI_Approach> <DRI_Approach agreement="All_Equal">It then computes the gradient vectors for the cells adjacent to each grid point—if the angle between two of them is 120 ◦ or greater, it adds the point to the medial surface sample.</DRI_Approach> <DRI_Approach agreement="All_Equal">We impose the 120 ◦ condition because we do not want the “noisy” parts of the medial surface—we want the points where skeleton joints are likely to lie.</DRI_Approach> <DRI_Approach agreement="All_Equal">For the same reason, Pinocchio filters out the sampled points that are too close to the character surface (within 2τ ).</DRI_Approach> <DRI_Background agreement="All_Equal">Wade discusses a similar condition in Chapter 4 of his thesis [2000].</DRI_Background> <Sentence agreement="All_Equal">Sphere Packing To pick out the graph vertices from the medial surface, Pinocchio packs spheres into the character as follows: it sorts the medial surface points by their distance to the surface (those that are farthest from the surface are first).</Sentence> <DRI_Approach agreement="All_Equal">Then it processes these points in order and if a point is outside all previously added spheres, adds the sphere centered at that point whose radius is the distance to the surface.</DRI_Approach> <DRI_Approach agreement="All_Equal">In other words, the largest spheres are added first, and no sphere contains the center of another sphere ( Figure 3 ).</DRI_Approach> <Sentence agreement="All_Equal">Although the procedure described above takes O(nb) time in the worst case (where n is the number of points, and b is the final number of spheres inserted), worst case behavior is rarely seen because most points are processed while there is a small number of large</Sentence>
          
            
            
            Figure 4: Constructed Graph Figure 5: The original and reduced quadruped skeleton
          
          <Sentence agreement="All_Equal">spheres.</Sentence> <DRI_Approach agreement="All_Equal">In fact, this step typically takes less than 1% of the time of the entire algorithm.</DRI_Approach>
          <Sentence agreement="All_Equal">Graph Construction The final discretization step constructs the edges of the graph by connecting some pairs of sphere centers (Figure 4).</Sentence> <DRI_Approach agreement="All_Equal">Pinocchio adds an edge between two sphere centers if the spheres intersect.</DRI_Approach> <DRI_Approach agreement="All_Equal">We would also like to add edges between spheres that do not intersect if that edge is well inside the surface and if that edge is “essential.</DRI_Approach><DRI_Approach agreement="All_Equal">” For example, the neck and left shoulder spheres of the character in Figure 3 are disjoint, but there should still be an edge between them.</DRI_Approach> <DRI_Approach agreement="All_Equal">The precise condition Pinocchio uses is that the distance from any point of the edge to the surface must be at least half of the radius of the smaller sphere, and the closest sphere centers to the midpoint of the edge must be the edge endpoints.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">The latter condition is equivalent to the requirement that additional edges must be in the Gabriel graph of the sphere centers (see e.g. [Jaromczyk and Toussaint 1992]).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">While other conditions can be formulated, we found that the Gabriel graph provides a good balance between sparsity and connectedness.</DRI_Approach> <DRI_Approach agreement="All_Equal">Pinocchio precomputes the shortest paths between all pairs of vertices in this graph to speed up penalty function evaluation.</DRI_Approach>
        
        
          <h2>3.2 Reduced Skeleton G = (V, E)</h2>
          <DRI_Approach agreement="All_Equal">The discretization stage constructs a geometric graph into which Pinocchio needs to embed the given skeleton in an optimal way.</DRI_Approach> <DRI_Approach agreement="All_Equal">The skeleton is given as a rooted tree on s joints.</DRI_Approach> <DRI_Approach agreement="All_Equal">To reduce the degrees of freedom, for the discrete embedding, Pinocchio works with a reduced skeleton, in which all bone chains have been merged (all degree two joints, such as knees, eliminated), as shown in Figure 5 .</DRI_Approach> <DRI_Approach agreement="All_Equal">The reduced skeleton thus has only r joints.</DRI_Approach> <DRI_Approach agreement="All_Equal">This works because once Pinocchio knows where the endpoints of a bone chain are in V , it can compute the intermediate joints by taking the shortest path between the endpoints and splitting it in accordance with the proportions of the unreduced skeleton.</DRI_Approach> <DRI_Approach agreement="All_Equal">For the humanoid skeleton we use, for example, s = 18, but r = 7; without a reduced skeleton, the optimization problem would typically be intractable.</DRI_Approach> <DRI_Approach agreement="All_Equal">Therefore, the discrete skeleton embedding problem is to find the embedding of the reduced skeleton into G, represented by an rtuple v = (v 1 , . . . , v r ) of vertices in V , which minimizes a penalty function f (v) that is designed to penalize differences in the embedded skeleton from the given skeleton.</DRI_Approach>
        
        
          <h2>3.3 Discrete Penalty Function</h2>
          <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The discrete penalty function has great impact on the generality and quality of the results.</DRI_Approach> <DRI_Approach agreement="All_Equal">A good embedding should have the proportions, bone orientations, and size similar to the given skeleton.</DRI_Approach> <DRI_Approach agreement="All_Equal">The paths representing the bone chains should be disjoint, if possible.</DRI_Approach> <DRI_Approach agreement="All_Equal">Joints of the skeleton may be marked as “feet,” in which case they should be close to the bottom of the character.</DRI_Approach> <DRI_Approach agreement="All_Equal">Designing a penalty function that satisfies all of these requirements simultaneously is difficult.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Instead we found it easier to design penalties independently and then rely on learning a proper weighting for a global penalty that combines each term.</DRI_Approach> <Sentence agreement="All_Equal">The Setup We represent the penalty function f as a linear combination of k “basis” penalty functions: f (v) = P k i=1 γ i b i (v).</Sentence> <DRI_Approach agreement="All_Equal">Pinocchio uses k = 9 basis penalty functions constructed by hand.</DRI_Approach> <DRI_Approach agreement="All_Equal">They penalize short bones, improper orientation between joints, length differences in bones marked symmetric, bone chains sharing vertices, feet away from the bottom, zero-length bone chains, improper orientation of bones, degree-one joints not embedded at extreme vertices, and joints far along bone-chains but close in the graph [Baran and Popović 2007a].</DRI_Approach> <DRI_Approach agreement="All_Equal">We determine the weights Γ = (γ 1 , . . . , γ k ) semi-automatically via a new maximum margin approach inspired by support vector machines.</DRI_Approach> <DRI_Approach agreement="All_Equal">Suppose that for a single character, we have several example embeddings, each marked “good” or “bad”.</DRI_Approach> <DRI_Approach agreement="All_Equal">The basis penalty functions assign a feature vector b(v) = (b 1 (v), . . . , b k (v)) to each example embedding v.</DRI_Approach> <DRI_Approach agreement="All_Equal">Let p 1 , . . . , p m be the k-dimensional feature vectors of the good embeddings and let q 1 , . . . , q n be the feature vectors of the bad embeddings.</DRI_Approach> <Sentence agreement="All_Equal">Maximum Margin To provide context for our approach, we review the relevant ideas from the theory of support vector machines.</Sentence> <DRI_Background ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">See Burges [1998] for a much more complete tutorial.</DRI_Background> <DRI_Approach agreement="All_Equal">If our goal were to automatically classify new embeddings into “good” and “bad” ones, we could use a support vector machine to learn a maximum margin linear classifier.</DRI_Approach> <DRI_Approach ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">In its simplest form, a support vector machine finds the hyperplane that separates the p i ’s from the q i ’s and is as far away from them as possible.</DRI_Approach> <DRI_Approach ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">More precisely, if Γ is a k-dimensional vector with Γ = 1, the classification margin of the best hyperplane normal to Γ is 1 2 ` min n i=1 Γ T q i − max m i=1 Γ T p i  ́ .</DRI_Approach> <DRI_Approach agreement="All_Equal">Recalling that the total penalty of an embedding v is Γ T b(v), we can think of the maximum margin Γ as the one that best distinguishes between the best “bad” embedding and the worst “good” embedding in the training set.</DRI_Approach> <DRI_Approach agreement="All_Equal">In our case, however, we do not need to classify embeddings, but rather find a Γ such that the embedding with the lowest penalty f (v) = Γ T b(v) is likely to be good.</DRI_Approach> <DRI_Approach agreement="All_Equal">To this end, we want Γ to distinguish between the best “bad” embedding and the best “good” embedding, as illustrated in Figure 6 .</DRI_Approach> <DRI_Approach agreement="All_Equal">We therefore wish to maximize the optimization margin (subject to Γ = 1), which we define as: n m min Γ T q i − min Γ T p i .</DRI_Approach> <Sentence agreement="All_Equal">i=1 i=1 Because we have different characters in our training set, and because the embedding quality is not necessarily comparable between different characters, we find the Γ that maximizes the minimum margin over all of the characters.</Sentence> <Sentence agreement="All_Equal">Our approach is similar to margin-based linear structured classification [Taskar et al. 2003], the problem of learning a classifier that to each problem instance (cf.</Sentence> <Sentence agreement="All_Equal">character) assigns the discrete label (cf.</Sentence> <Sentence agreement="All_Equal">embedding) that minimizes the dot product of a weights vector with basis functions of the problem instance and label.</Sentence> <DRI_Approach agreement="All_Equal">The key difference is that structured classification requires an explicit loss function (in our case, the knowledge of the quality of all possible skeleton embeddings for each character in the training set), whereas our approach only makes use of the loss function on the training labels and allows for the possibility of multiple correct labels.</DRI_Approach> <DRI_Approach agreement="All_Equal">This possibility of multiple correct skeleton embeddings prevented us from formulating our margin maximization problem as a convex optimization problem.</DRI_Approach> <DRI_Approach agreement="All_Equal">However, multiple correct skeleton embeddings are necessary for our problem in cases such as the hand joint being embedded into different fingers.</DRI_Approach>
         <Sentence agreement="All_Equal"> </Sentence>3
          To appear in the ACM SIGGRAPH conference proceedings
          Good embeddings (p i ’s): Bad embeddings (q i ’s): b 2 Best Γ Margin 0 b 1
          
            Figure 6: Illustration of optimization margin: marked skeleton embeddings in the space of their penalties (b i ’s)
          
          <Sentence agreement="All_Equal">Learning Procedure The problem of finding the optimal Γ does not appear to be convex.</Sentence> <DRI_Approach agreement="All_Equal">However, an approximately optimal Γ is acceptable, and the search space dimension is sufficiently low (9 in our case) that it is feasible to use a continuous optimization method.</DRI_Approach> <DRI_Approach agreement="All_Equal">We use the Nelder-Mead method [Nelder and Mead 1965] starting from random Γ’s.</DRI_Approach> <DRI_Approach agreement="All_Equal">We start with a cube [0, 1] k , pick random normalized Γ’s, and run Nelder-Mead from each of them.</DRI_Approach> <DRI_Approach agreement="All_Equal">We then take the best Γ, use a slightly smaller cube around it, and repeat.</DRI_Approach> <DRI_Approach agreement="All_Equal">To create our training set of embeddings, we pick a training set of characters, manually choose Γ, and use it to construct skeleton embeddings of the characters.</DRI_Approach> <DRI_Approach agreement="All_Equal">For every character with a bad embedding, we manually tweak Γ until a good embedding is produced.</DRI_Approach> <DRI_Approach agreement="All_Equal">We then find the maximum margin Γ as described above and use this new Γ to construct new skeleton embeddings.</DRI_Approach> <DRI_Approach agreement="All_Equal">We manually classify the embeddings that we have not previously seen, augment our training set with them, and repeat the process.</DRI_Approach> <Sentence ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="Sentence">If Γ eventually stops changing, as happened on our training set, we use the found Γ. It is also possible that a positive margin Γ cannot be found, indicating that the chosen basis functions are probably inadequate for finding good embeddings for all characters in the training set.</Sentence> <DRI_Approach agreement="All_Equal">For training, we used 62 different characters (Cosmic Blobs models, free models from the web, scanned models, and Teddy models), and Γ was stable with about 400 embeddings.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The weights we learned resulted in good embeddings for all of the characters in our training set; we could not accomplish this by manually tuning the weights.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Examining the optimization results and the extremal embeddings also helped us design better basis penalty functions.</DRI_Approach> <DRI_Approach agreement="All_Equal">Although this process of finding the weights is labor-intensive, it only needs to be done once.</DRI_Approach> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">According to our tests, if the basis functions are carefully chosen, the overall penalty function generalizes well to both new characters and new skeletons.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Therefore, a novice user will be able to use the system, and more advanced users will be able to design new skeletons without having to learn new weights.</DRI_Outcome>
        
        
          <h2>3.4 Discrete Embedding</h2>
          <Sentence ann2="DRI_Approach" agreement="3diff" ann1="Sentence" ann3="DRI_Outcome">Computing a discrete embedding that minimizes a general penalty function is intractable because there are exponentially many embeddings.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">However, if it is easy to estimate a good lower bound on f from a partial embedding (of the first few joints), it is possible to use a branch-and-bound method.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">Pinocchio uses this idea: it maintains a priority queue of partial embeddings ordered by their lower bound estimates.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">At every step, it takes the best partial embedding from the queue, extends it in all possible ways with the next joint, and pushes the results back on the queue.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">The first full embedding extracted is guaranteed to be the optimal one.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">This is essentially the A* algorithm on the tree of possible embeddings.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">To speed up the process and conserve memory, if a partial embedding has a very high lower bound, it is rejected immediately and not inserted into the queue.</DRI_Approach> <Sentence ann2="DRI_Approach" agreement="3diff" ann1="Sentence" ann3="DRI_Outcome">Although this algorithm is still worst-case exponential, it is fast on most real problems with the skeletons we tested.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">We considered adapting an approximate graph matching algorithm, like [Gold and Rangarajan 1996], which would work much faster and enable more complicated reduced skeletons.</DRI_Approach> <Sentence ann2="DRI_Approach" agreement="3diff" ann1="Sentence" ann3="DRI_Outcome">However, computing the exact optimum simplified penalty function design and debugging.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">The joints of the skeleton are given in order, which induces an order on the joints of the reduced skeleton.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">Referring to the joints by their indices (starting with the root at index 1), we define the parent function p R on the reduced skeleton, such that p R (i) (for 1 &lt; i ≤ r) is the index of the parent of joint i.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">We require that the order in which the joints are given respects the parent relationship, i.e. p R (i) &lt; i.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">Our penalty function (f ) can be expressed as the sum of independent functions of bone chain endpoints (f i ’s) and a term (f D ) that incorporates the dependence between different joint positions.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">The dependence between joints that have not been embedded can be ignored to obtain a lower bound on f .</DRI_Approach> <Sentence ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="Sentence">More precisely, f can be written as: r r f (v 1 , . . . , v r ) = X f i (v i , v p R (i) ) + X f D (v 1 , . . . , v i ).</Sentence> <Sentence agreement="All_Equal">i=2 i=2 A lower bound when the first k joints are embedded is then: k k X f i (v i , v p R (i) ) + X f D (v 1 , . . . , v i ) + i=2 i=2 + X min f i (v i , v p R (i) ) v i ∈V {i&gt;k|p R (i)≤k} If f D is small compared to the f i ’s, as is often the case for us, the lower bound is close to the true value of f .</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">Because of this lower bound estimate, the order in which joints are embedded is very important to the performance of the optimization algorithm.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">High degree joints should be embedded first because they result in more terms in the rightmost sum of the lower bound, leading to a more accurate lower bound.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">For example, our biped skeleton has only two joints of degree greater than two, so after Pinocchio has embedded them, the lower bound estimate includes f i terms for all of the bone chains.</DRI_Approach> <Sentence ann2="DRI_Approach" agreement="3diff" ann1="Sentence" ann3="DRI_Outcome">Because there is no perfect penalty function, discrete embedding will occasionally produce undesirable results (see Model 13 in Figure 9).</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">In such cases it is possible for the user to provide manual hints in the form of constraints for reduced skeleton joints.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">For example, such a hint might be that the left hand of the skeleton should be embedded at a particular vertex in G (or at one of several vertices).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">Embeddings that do not satisfy the constraints are simply not considered by the algorithm.</DRI_Approach>
          4
          To appear in the ACM SIGGRAPH conference proceedings
        
        
          <h2>3.5 Embedding Refinement</h2>
          <DRI_Approach agreement="All_Equal">Pinocchio takes the optimal embedding of the reduced skeleton found by discrete optimization and reinserts the degree-two joints by splitting the shortest paths in G in proportion to the given skeleton.</DRI_Approach> <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">The resulting skeleton embedding should have the general shape we are looking for, but typically, it will not fit nicely inside the character.</DRI_Approach> <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">Also, smaller bones are likely to be incorrectly oriented because they were not important enough to influence the discrete optimization.</DRI_Approach> <DRI_Approach agreement="All_Equal">Embedding refinement corrects these problems by minimizing a new continuous penalty function ( Figure 7 ).</DRI_Approach> <DRI_Approach agreement="All_Equal">For the continuous optimization, we represent the embedding of the skeleton as an s-tuple of joint positions (q 1 , . . . , q s ) in R 3 .</DRI_Approach> <DRI_Approach agreement="All_Equal">Because we are dealing with an unreduced skeleton, and discrete optimization has already found the correct general shape, the penalty function can be much simpler than the discrete penalty function.</DRI_Approach> <DRI_Approach agreement="All_Equal">The continuous penalty function g that Pinocchio tries to minimize is the sum of penalty functions over the bones plus an asymmetry penalty: where p S is the parent function for the unreduced skeleton (analogous to p R ).</DRI_Approach> <DRI_Approach agreement="All_Equal">Each g i penalizes bones that do not fit inside the surface nicely, bones that are too short, and bones that are oriented differently from the given skeleton: g i = α S g i S + α L g i L + α O g i O .</DRI_Approach> <DRI_Approach agreement="All_Equal">Unlike the discrete case, we choose the α’s by hand because there are only four of them [Baran and Popović 2007a].</DRI_Approach> <DRI_Approach agreement="All_Equal">Any continuous optimization technique [Gill et al. 1989] should produce good results.</DRI_Approach> <DRI_Approach agreement="All_Equal">Pinocchio uses a gradient descent method that takes advantage of the fact that there are relatively few interactions.</DRI_Approach> <DRI_Approach agreement="All_Equal">As a subroutine, it uses a step-doubling line search: starting from a given point (in R 3s ), it takes steps in the given optimization direction, doubling step length until the penalty function increases.</DRI_Approach> <DRI_Approach agreement="All_Equal">Pinocchio intersperses a line search in the gradient direction with line searches in the gradient direction projected onto individual bones.</DRI_Approach> <DRI_Approach agreement="All_Equal">Repeating the process 10 times is usually sufficient for convergence.</DRI_Approach>
          
            
            Figure 7: The embedded skeleton after discrete embedding (blue) and the results of embedding refinement (dark red)
          
          s g(q 1 , . . . , q s ) = α A g A (q 1 , . . . , q s ) + X g i (q i , q p S (i) ) i=2
        
      
      
        <h1>4 Skin Attachment</h1>
        <DRI_Approach agreement="All_Equal">The character and the embedded skeleton are disconnected until skin attachment specifies how to apply deformations of the skeleton to the character mesh.</DRI_Approach> <DRI_Approach agreement="All_Equal">Although we could make use of one of the various mesh editing techniques for the actual mesh deformation, we choose to focus on the standard linear blend skinning (LBS) method because of its widespread use.</DRI_Approach> <DRI_Approach agreement="All_Equal">If v j is the position of vertex j, T i is the transformation of the i th bone, and w j i is the weight of the i th bone for vertex j, LBS gives the position of the transformed vertex j as P i w j i T i (v j ).</DRI_Approach> <DRI_Approach agreement="All_Equal">The attachment problem is finding bone weights w i for the vertices—how much each bone transform affects each vertex.</DRI_Approach> <DRI_Approach agreement="All_Equal">There are several properties we desire of the weights.</DRI_Approach> <DRI_Approach agreement="All_Equal">First of all, they should not depend on the mesh resolution.</DRI_Approach> <DRI_Approach agreement="All_Equal">Second, for the results to look good, the weights need to vary smoothly along the surface.</DRI_Approach> <DRI_Approach agreement="All_Equal">Finally, to avoid folding artifacts, the width of a transition between two bones meeting at a joint should be roughly proportional to the distance from the joint to the surface.</DRI_Approach> <DRI_Approach agreement="All_Equal">Although a scheme that assigns bone weights purely based on proximity to bones can be made to satisfy these properties, such schemes will often fail because they ignore the character’s geometry: for example, part of the torso may become attached to an arm.</DRI_Approach> <DRI_Approach agreement="All_Equal">Instead, we use the analogy to heat equilibrium to find the weights.</DRI_Approach> <DRI_Approach agreement="All_Equal">Suppose we treat the character volume as an insulated heat-conducting body and force the temperature of bone i to be 1 while keeping the temperature of all of the other bones at 0.</DRI_Approach> <DRI_Approach agreement="All_Equal">Then we can take the equilibrium temperature at each vertex on the surface as the weight of bone i at that vertex.</DRI_Approach> <DRI_Unspecified agreement="All_Equal">Figure 8 illustrates this in two dimensions.</DRI_Unspecified> <DRI_Approach agreement="All_Equal">Solving for heat equilibrium over a volume would require tessellating the volume and would be slow.</DRI_Approach> <DRI_Approach agreement="All_Equal">Therefore, for simplicity, Pinocchio solves for equilibrium over the surface only, but at some vertices, it adds the heat transferred from the nearest bone.</DRI_Approach> <Sentence agreement="All_Equal">i The equilibrium over the surface for bone i is given by ∂w = ∂t ∆w i + H(p i − w i ) = 0, which can be written as</Sentence>
        5
        To appear in the ACM SIGGRAPH conference proceedings
        
          
          Figure 8: Top: heat equilibrium for two bones. Bottom: the result of rotating the right bone with the heat-based attachment
        
        
          1
          −∆w i + Hw i = Hp i ,
        
        <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">where ∆ is the discrete surface Laplacian, calculated with the cotangent formula [Meyer et al. 2003], p i is a vector with p i j = 1 if the nearest bone to vertex j is i and p i j = 0 otherwise, and H is the diagonal matrix with H jj being the heat contribution weight of the nearest bone to vertex j.</Sentence> <Sentence ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="Sentence">Because ∆ has units of length −2 , so must H. Letting d(j) be the distance from vertex j to the nearest bone, Pinocchio uses H jj = c/d(j) 2 if the shortest line segment from the vertex to the bone is contained in the character volume and H jj = 0 if it is not.</Sentence> <DRI_Approach agreement="All_Equal">It uses the precomputed distance field to determine whether a line segment is entirely contained in the character volume.</DRI_Approach> <DRI_Approach agreement="All_Equal">For c ≈ 0.22, this method gives weights with similar transitions to those computed by finding the equilibrium over the volume.</DRI_Approach> <DRI_Approach agreement="All_Equal">Pinocchio uses c = 1 (corresponding to anisotropic heat diffusion) because the results look more natural.</DRI_Approach> <DRI_Approach agreement="All_Equal">When k bones are equidistant from vertex j, heat contributions from all of them are used: p j is 1/k for all of them, and H jj = kc/d(j) 2 .</DRI_Approach> <DRI_Approach agreement="All_Equal">Equation (1) is a sparse linear system, and the left hand side matrix −∆ + H does not depend on i, the bone we are interested in.</DRI_Approach> <DRI_Approach agreement="All_Equal">Thus we can factor the system once and back-substitute to find the weights for each bone.</DRI_Approach> <DRI_Background ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Botsch et al. [2005] show how to use a sparse Cholesky solver to compute the factorization for this kind of system.</DRI_Background> <DRI_Approach agreement="All_Equal">Pinocchio uses the TAUCS [Toledo 2003] library for this computation.</DRI_Approach> <DRI_Approach agreement="All_Equal">Note also that the weights w i sum to 1 for each vertex: if we sum (1) over i, we get (−∆ + H) P i w i = H · 1, which yields P i w i = 1.</DRI_Approach> <DRI_Approach agreement="All_Equal">It is possible to speed up this method slightly by finding vertices that are unambiguously attached to a single bone and forcing their weight to 1.</DRI_Approach> <DRI_Background ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">An earlier variant of our algorithm did this, but the improvement was negligible, and this introduced occasional artifacts.</DRI_Background>
      
      
        <h1>5 Results</h1>
        <DRI_Approach agreement="All_Equal">We evaluate Pinocchio with respect to the three criteria stated in the introduction: generality, quality, and performance.</DRI_Approach> <DRI_Approach agreement="All_Equal">To ensure an objective evaluation, we use inputs that were not used during development.</DRI_Approach> <DRI_Approach agreement="All_Equal">To this end, once the development was complete, we tested Pinocchio on 16 biped Cosmic Blobs models that we had not previously tried.</DRI_Approach>
        
          
          
          Figure 10: A centaur pirate with a centaur skeleton embedded looks at a cat with a quadruped skeleton embedded
        
        
          
          Figure 11: The human scan on the left is rigged by Pinocchio and is posed on the right by changing joint angles in the embedded skeleton. The well-known deficiencies of LBS can be seen in the right knee and hip areas.
        
        
          <h2>5.1 Generality</h2>
           <DRI_Unspecified ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Outcome">Figure 9 shows our 16 test characters and the skeletons Pinocchio embedded.</DRI_Unspecified> <DRI_Outcome agreement="All_Equal">The skeleton was correctly embedded into 13 of these models (81% success).</DRI_Outcome> <DRI_Outcome agreement="All_Equal">For Models 7, 10 and 13, a hint for a single joint was sufficient to produce a good embedding.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">These tests demonstrate the range of proportions that our method can tolerate: we have a well-proportioned human (Models 1–4, 8), large arms and tiny legs (6; in 10, this causes problems), and large legs and small arms (15; in 13, the small arms cause problems).</DRI_Outcome> <DRI_Outcome agreement="All_Equal">For other characters we tested, skeletons were almost always correctly embedded into well-proportioned characters whose pose matched the given skeleton.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Pinocchio was even able to transfer a biped walk onto a human hand, a cat on its hind legs, and a donut.</DRI_Outcome> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Outcome">The most common issues we ran into on other characters were: • The thinnest limb into which we may hope to embed a bone has a radius of 2τ .</Sentence> <DRI_Outcome agreement="All_Equal">Characters with extremely thin limbs often fail because the the graph we extract is disconnected.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Reducing τ , however, hurts performance.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">• Degree 2 joints such as knees and elbows are often positioned incorrectly within a limb.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">We do not know of a reliable way to identify the right locations for them: on some characters they are thicker than the rest of the limb, and on others they are thinner.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Although most of our tests were done with the biped skeleton, we have also used other skeletons for other characters ( Figure 10 ).</DRI_Outcome>
        
        
          <h2>5.2 Quality</h2>
           <DRI_Unspecified ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Outcome">Figure 11 shows the results of manually posing a human scan using our attachment.</DRI_Unspecified> <DRI_Outcome ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Our video [Baran and Popović 2007b] demonstrates the quality of the animation produced by Pinocchio.</DRI_Outcome>
          6
         <Sentence agreement="All_Equal"> </Sentence>To appear in the ACM SIGGRAPH conference proceedings
          1. <Sentence agreement="All_Equal">2.</Sentence> <Sentence agreement="All_Equal">3.</Sentence>
          
            
          
          <Sentence agreement="All_Equal">7.</Sentence>
          
            
          
          <Sentence agreement="All_Equal">8.</Sentence> <Sentence agreement="All_Equal">9.</Sentence>
          <Sentence agreement="All_Equal">13.</Sentence>
          
            
            
          
          <Sentence agreement="All_Equal">14.</Sentence>
          
            Figure 9: Test Results for Skeleton Embedding
          
          
            
              
                
                  
                     Model
                     3
                     10
                     11
                     Mean
                  
                
                
                  
                     Number of Vertices
                     19,001
                     34,339
                     56,856
                     33,224
                  
                  
                     Discretization Time
                     10.3s
                     25.8s
                     68.2s
                     24.3s
                  
                  
                     Embedding Time
                     1.4s
                     29.1s
                     5.7s
                     5.2s
                  
                  
                     Attachment Time
                     0.9s
                     1.9s
                     3.2s
                     1.8s
                  
                
                
                  
                     Total Time
                     12.6s
                     56.8s
                     77.1s
                     31.3s
                  
                
              
            
            Model 3 10 11 Mean Number of Vertices 19,001 34,339 56,856 33,224 Discretization Time 10.3s 25.8s 68.2s 24.3s Embedding Time 1.4s 29.1s 5.7s 5.2s Attachment Time 0.9s 1.9s 3.2s 1.8s Total Time 12.6s 56.8s 77.1s 31.3s
            Table 1: Timings for three representative models and the mean over our 16 character test set
          
          <DRI_Outcome agreement="All_Equal">The quality problems of our attachment are a combination of the deficiencies of our automated weights generation as well as those inherent in LBS.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">A common class of problems is caused by Pinocchio being oblivious to the material out of which the character is made: the animation of both a dress and a knight’s armor has an unrealistic, rubbery quality.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Other problems occur at difficult areas, such as hips and the shoulder/neck region, where hand-tuned weights could be made superior to those found by our algorithm.</DRI_Outcome>
        
        
          <h2>5.3 Performance</h2>
           <DRI_Outcome ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Table 1 shows the fastest and slowest timings of Pinocchio rigging the 16 models discussed in Section 5.1 on a 1.73 MHz Intel Core Duo with 1GB of RAM.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">Pinocchio is single-threaded so only one core was used.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">We did not run timing tests on denser models because someone wishing to create real-time animation is likely to keep the triangle count low.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">Also, because of our volume-based approach, once the distance field has been computed, subsequent discretization and embedding steps do not depend on the given mesh size.</DRI_Outcome> For the majority of models, the running time is dominated by the discretization stage, and that is dominated by computing the distance field. <DRI_Outcome agreement="All_Equal">Embedding refinement takes about 1.2 seconds for all of these models, and the discrete optimization consumes the rest of the embedding time.</DRI_Outcome>
        
      
      
        <h1>6 Conclusion and Future Work</h1>
        <DRI_Outcome_Contribution agreement="All_Equal">We have presented the first method for automatically rigging an unfamiliar character for skeletal animation.</DRI_Outcome_Contribution> <Sentence agreement="All_Equal">In conjunction with ex-
        4.</Sentence> <Sentence agreement="All_Equal">5.</Sentence> <Sentence agreement="All_Equal">6.</Sentence>
        
          
        
        <Sentence agreement="All_Equal">10.</Sentence> <Sentence agreement="All_Equal">11.</Sentence>
        
          
        
        <Sentence agreement="All_Equal">12.</Sentence>
        <Sentence agreement="All_Equal">15.</Sentence>
        
          
          
        
        <Sentence agreement="All_Equal">16.</Sentence>
        <Sentence agreement="All_Equal">isting techniques, it allows a user to go from a static mesh to an animated character quickly and effortlessly.</Sentence> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">We have shown that using this method, Pinocchio can animate a wide range of characters.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">We also believe that some of our techniques, such as finding LBS weights and using examples to learn the weights of a linear combination of penalty functions, can be useful in other contexts.</DRI_Outcome> <DRI_FutureWork agreement="All_Equal">We have several ideas for improving Pinocchio that we have not yet tried.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Discretization could be improved by packing ellipsoids instead of spheres.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Although this is more difficult, we believe it would greatly reduce the size of the graph, resulting in faster and higher quality discrete embeddings.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Animation quality can be improved with a better skinning model [Kavan and Zára ˇ 2005] (although possibly at the cost of performance).</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">One approach would be to use a technique [Wang et al. 2007] that corrects LBS errors by using example meshes, which we could synthesize using slower, but more accurate deformation techniques.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">A more involved approach would be automatically building a tetrahedral mesh around the embedded skeleton and applying the dynamic deformation method of Capell et al. [2002].</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Combining retargetting with joint limits should eliminate some artifacts in the motion.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">A better retargetting scheme could be used to make animations more physically plausible and prevent global self-intersections.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Finally, it would be nice to eliminate the assumption that the character must have a well-defined interior.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Beyond Pinocchio’s current capabilities, an interesting problem is dealing with hand animation to give animated characters the ability to grasp objects, type, or speak sign language.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">The variety of types of hands makes this challenging (see, for example, Models 13, 5, 14, and 11 in Figure 9 ).</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Automatically rigging characters for facial animation is even more difficult, but a solution requiring a small amount of user assistance may succeed.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Combined with a system for motion synthesis [Arikan et al. 2003], this would allow users to begin interacting with their creations.</DRI_FutureWork>
      
      
        <h1>7 Acknowledgments</h1>
        <DRI_Unspecified agreement="All_Equal">We thank Yeuhi Abe and Eugene Hsu for help with motion capture.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">Thanks to Soonmin Bae, Inna Baran, Frédo Durand, Sylvain Paris, Ariel Shamir, Daniel Vlasic, and Robert Wang for their helpful feedback.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">Thanks to Emily Whiting for narrating the video.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">We thank Dragomir Anguelov for the human meshes.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">We would also like to thank Solidworks for the permission to use Cosmic Blobs models.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">This work was supported by a grant from Solidworks Corporation.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">The first author was also supported by an NSF Graduate Research Fellowship.</DRI_Unspecified>
        7
        To appear in the ACM SIGGRAPH conference proceedings
      
      
        <h1>References</h1>
        
          A NDERSON , D., F RANKEL , J. L., M ARKS , J., A GARWALA , A., B EARDSLEY , P., H ODGINS , J., L EIGH , D., R YALL , K., S UL LIVAN , E., AND Y EDIDIA , J. S. 2000. Tangible interaction + graphical interpretation: a new approach to 3d modeling. In Proceedings of ACM SIGGRAPH 2000, Annual Conference Series, 393–402.
          A RIKAN , O., F ORSYTH , D. A., AND O’B RIEN , J. F. 2003. Motion synthesis from annotations. ACM Transactions on Graphics 22, 3 (July), 402–408.
          B ARAN , I., AND P OPOVI C  ́ , J., 2007. Penalty functions for automatic rigging and animation of 3d characters. http://people.csail.mit.edu/ibaran/penalty.pdf.
          B ARAN , I., AND P OPOVI C  ́ , J., 2007. Pinocchio results video. http://people.csail.mit.edu/ibaran/pinocchio.avi.
          B OTSCH , M., B OMMES , D., AND K OBBELT , L. 2005. Efficient linear system solvers for mesh processing. In IMA Conference on the Mathematics of Surfaces, 62–83.
          B URGES , C. 1998. A Tutorial on Support Vector Machines for Pattern Recognition. Data Mining and Knowledge Discovery 2, 2, 121–167.
          C APELL , S., G REEN , S., C URLESS , B., D UCHAMP , T., AND P OPOVI C  ́ , Z. 2002. Interactive skeleton-driven dynamic deformation. ACM Transactions on Graphics 21, 3 (Aug.), 586–593.
          C HOI , K.-J., AND K O , H.-S. 2000. Online motion retargetting. Journal of Visualization and Computer Animation 11, 5 (Dec.), 223–235.
          F RISKEN , S. F., P ERRY , R. N., R OCKWOOD , A. P., AND J ONES , T. R. 2000. Adaptively sampled distance fields: A general representation of shape for computer graphics. In Proceedings of ACM SIGGRAPH 2000, Annual Conference Series, 249–254.
          G ILL , P. E., M URRAY , W., AND W RIGHT , M. H. 1989. Practical Optimization. Academic Press, London.
          G LEICHER , M. 2001. Comparing contraint-based motion editing methods. Graphical Models 63 (Aug.), 107–134.
          G OLD , S., AND R ANGARAJAN , A. 1996. A graduated assignment algorithm for graph matching. IEEE Transactions on Pattern Analysis and Machine Intelligence 18, 4, 377–388.
          I GARASHI , T., M ATSUOKA , S., AND T ANAKA , H. 1999. Teddy: A sketching interface for 3d freeform design. In Proceedings of ACM SIGGRAPH 1999, Annual Conference Series, 409–416.
          I GARASHI , T., M OSCOVICH , T., AND H UGHES , J. F. 2005. As-rigid-as-possible shape manipulation. ACM Transactions on Graphics 24, 3 (Aug.), 1134–1141.
          I GARASHI , T., M OSCOVICH , T., AND H UGHES , J. F. 2005. Spatial keyframing for performance-driven animation. In Symposium on Computer Animation (SCA), 107–115.
          J AROMCZYK , J. W., AND T OUSSAINT , G. T. 1992. Relative neighborhood graphs and their relatives. Proceedings of IEEE 80, 9 (Sept.), 1502–1517.
          K ATZ , S., AND T AL , A. 2003. Hierarchical mesh decomposition using fuzzy clustering and cuts. ACM Transactions on Graphics 22, 3 (Aug.), 954–961.
          K AVAN , L., AND Z ˇ ARA  ́ , J. 2005. Spherical blend skinning: A realtime deformation of articulated models. In ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games, 9–16.
          K RY , P. G., J AMES , D. L., AND P AI , D. K. 2002. EigenSkin: Real time large deformation character skinning in hardware. In Symposium on Computer Animation (SCA), 153–160.
          L IPMAN , Y., S ORKINE , O., L EVIN , D., AND C OHEN -O R , D. 2005. Linear rotation-invariant coordinates for meshes. ACM Transactions on Graphics 24, 3 (Aug.), 479–487.
          L IU , P.-C., W U , F.-C., M A , W.-C., L IANG , R.-H., AND O UHY OUNG , M. 2003. Automatic animation skeleton using repulsive force field. In 11th Pacific Conference on Computer Graphics and Applications, 409–413.
          M EYER , M., D ESBRUN , M., S CHR ODER  ̈ , P., AND B ARR , A. H. 2003. Discrete differential-geometry operators for triangulated 2-manifolds. In Visualization and Mathematics III. SpringerVerlag, Heidelberg, 35–57.
          M OCCOZET , L., D ELLAS , F., M AGNENAT -T HALMANN , N., B I ASOTTI , S., M ORTARA , M., F ALCIDIENO , B., M IN , P., AND V ELTKAMP , R. 2004. Animatable human body model reconstruction from 3d scan data using templates. In CapTech Workshop on Modelling and Motion Capture Techniques for Virtual Environments, 73–79.
          N ELDER , J., AND M EAD , R. 1965. A simplex method for function minimization. Computer Journal 7, 308–313.
          T ASKAR , B., G UESTRIN , C., AND K OLLER , D. 2003. Maxmargin markov networks. In Advances in Neural Information Processing Systems (NIPS 2003).
          T EICHMANN , M., AND T ELLER , S. 1998. Assisted articulation of closed polygonal models. In Computer Animation and Simulation ’98, 87–102.
          T HORNE , M., B URKE , D., AND VAN DE P ANNE , M. 2004. Motion doodles: an interface for sketching character motion. ACM Transactions on Graphics 23, 3 (Aug.), 424–431.
          T OLEDO , S., 2003. TAUCS: A library of sparse linear solvers, version 2.2. http://www.tau.ac.il/ ∼stoledo/taucs.
          W ADE , L. 2000. Automated generation of control skeletons for use in animation. PhD thesis, The Ohio State University.
          W ANG , R., P ULLI , K., AND P OPOVI C  ́ , J. 2007. Real-time enveloping with rotational regression. ACM Transactions on Graphics 26, 3. In press.
          Y U , Y., Z HOU , K., X U , D., S HI , X., B AO , H., G UO , B., AND S HUM , H.-Y. 2004. Mesh editing with poisson-based gradient field manipulation. ACM Transactions on Graphics 23, 3 (Aug.), 644–651.
          Z HOU , K., H UANG , J., S NYDER , J., L IU , X., B AO , H., G UO , B., AND S HUM , H.-Y. 2005. Large mesh deformation using the volumetric graph laplacian. ACM Transactions on Graphics 24, 3 (Aug.), 496–503.
        
        8
      
    
  
</Document>