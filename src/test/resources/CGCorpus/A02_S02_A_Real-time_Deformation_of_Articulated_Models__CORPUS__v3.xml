<?xml version="1.0" encoding="UTF-8" ?>
<Document corpusVersion="3" name="A02_S02_A_Real-time_Deformation_of_Articulated_Models">
  
    9a62959e0e528de8c2462c1ec3ec886cc7c78f4db602ee297f4f7897c473786c
    3ww9
    http://dx.doi.org/10.1145/1053427.1053429
    Page 7 was found to have more than 100 embedded images.Image rendering was limited to the first 20, in reverse order of size.
  
  
    
      
        <article-title>Spherical Blend Skinning: A Real-time Deformation of Articulated Models</article-title>
      
      
        
          Ladislav Kavan ∗ Ji rı Zára ˇ Czech Technical University in Prague
          ∗
        
      
      <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">∗ e-mail: kavanl1@fel.cvut.cz
      Skin deformation based on an underlying skeleton is a common method to animate believable organic models.</Sentence> <DRI_Background agreement="All_Equal">The most widely used skeletal animation algorithm, linear blend skinning, is also known as skeleton subspace deformation, vertex blending, or enveloping.</DRI_Background> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">It runs in real-time even on a low-end hardware but it is also notorious for its failures, such as the collapsing-joints artifacts.</DRI_Challenge> <DRI_Outcome_Contribution agreement="All_Equal">We present a new algorithm which removes these shortcomings while maintaining almost the same time and memory complexity as the linear blend skinning.</DRI_Outcome_Contribution> <DRI_Outcome_Contribution ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome">Unlike other approaches, our method works with exactly the same input data as the popular linear version.</DRI_Outcome_Contribution> <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">This minimizes the cost of upgrade from linear to spherical blend skinning in many existing applications: the data structures and models need no change at all.</DRI_Outcome_Contribution> <DRI_Challenge_Goal ann2="DRI_Approach" agreement="3diff" ann1="DRI_Challenge_Goal" ann3="DRI_Outcome">The paper discusses also theoretical properties of rotation interpolation, essential to spherical blend skinning.</DRI_Challenge_Goal>
	<h2>CR Categories: </h2>CR Categories: I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism—Animation <h2>Keywords: </h2>skinning, deformation, skeletal animation		  
    
    
      
        <h1>1 Introduction</h1>
      
      <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">Real-time animation of deformable objects is always a compromise between visual fidelity and computation complexity.</DRI_Challenge> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">Other aspects are quite important as well, for example the amount of artists work necessary to design the model.</DRI_Challenge> <DRI_Background agreement="All_Equal">Therefore, there exist many algorithms for modeling deformable objects in the literature.</DRI_Background> <DRI_Background agreement="All_Equal">They differ by the intended area of application and generality of allowed models.</DRI_Background> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge_Goal" ann3="DRI_Approach">We focus on the real-time animation systems in this paper.</DRI_Approach> <DRI_Background agreement="All_Equal">Its most popular representative, known generally as the skeletal animation, is based on simple but versatile structure.</DRI_Background> <DRI_Background agreement="All_Equal">It consists of joints, given by their position and orientation.</DRI_Background> <DRI_Background agreement="All_Equal">The segments connecting the joints are conveniently interpreted as bones.</DRI_Background> <DRI_Background agreement="All_Equal">The skeleton is, formally speaking, a tree whose nodes are identified with the joints and edges with the bones.</DRI_Background> <DRI_Background agreement="All_Equal">The only displayed element is a skin, a 3D polygonal mesh, usually equipped with normal and texture data.</DRI_Background> <DRI_Background agreement="All_Equal">Although the terminology is adopted from the virtual humanoid modeling, the skeletal animation is not limited to character animation – it can be applied to a wide range of soft objects, including imaginary (cartoon) creatures, plants, furniture, etc.</DRI_Background> <DRI_Background agreement="All_Equal">This is an apparent advantage over complex systems which rely on explicit anatomy.</DRI_Background> <DRI_Background agreement="All_Equal">The skeleton simplifies the animation task considerably: instead of animating each vertex individually, it is sufficient to manipulate the skeleton, and the skin deforms automatically.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">The skeletal animation in general does not specify how exactly the skeleton posture should be propagated to the skin.</DRI_Background> <DRI_Background agreement="All_Equal">However, there is an established standard used in majority of real-time 3D applications.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Background">It comes by many names, all relating to the same algorithm: linear blend skinning (LBS), skeleton subspace deformation, vertex blending, enveloping, or simply skinning.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Background">Basically, this algorithm blends between rigidly transformed vertices using vertex weights, which denote the amount of influence of individual joints.</DRI_Background> <DRI_Challenge agreement="All_Equal">Although LBS is very fast and advantageous to graphics hardware, it suffers from inherent artifacts, known as ”collapsing joints”, ”twisting elbow problem” or a ”candy-wrapper artifact”.</DRI_Challenge> <DRI_Challenge agreement="All_Equal">In general, the mesh deformed by LBS loses volume as the joint rotation increases.</DRI_Challenge> <DRI_Unspecified agreement="All_Equal">The cause of this phenomena is explained in section 3, together with the LBS algorithm itself.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">The structure of the paper is as follows: in the next section, we summarize the previous work concerning real-time skin deformation and sketch our solution.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">In section 3, we analyze the problems of the LBS algorithm.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">Our approach to resolve these problems is presented in section 4.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">In section 5, we compare the results and discuss possible enhancements.</DRI_Unspecified>
      
        <h1>2 Related Work</h1>
      
      <DRI_Background agreement="All_Equal">An early contribution concerning the animation of deformable objects is [Magnenat-Thalmann et al. 1988], which considers the movement of a human hand.</DRI_Background> <DRI_Background agreement="All_Equal">First 3D characters used in numerous computer games were animated by simple, often unpublished algorithms.</DRI_Background> <DRI_Background agreement="All_Equal">Later on, the basic principles of LBS were described by the game development community [Lander 1998; Lander 1999].</DRI_Background> <DRI_Background agreement="All_Equal">The artifacts of LBS were discovered soon [Weber 2000].</DRI_Background> <DRI_Background agreement="All_Equal">An improvement based on addition of auxiliary joints has been also proposed in [Weber 2000].</DRI_Background> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">Although this reduces the artifacts, the skin to joints relationship must be re-designed after joint addition.</DRI_Challenge> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">The number and location of the additional joints remains questionable.</DRI_Background> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">Another problem is how the movement of the original skeleton should be propagated into the augmented one.</DRI_Challenge> <DRI_Background agreement="All_Equal">More formal articles consider skin deformation as an interpolation problem, such as [Lewis et al. 2000].</DRI_Background> <DRI_Background agreement="All_Equal">They use radial basis functions to interpolate between example skins with different shapes.</DRI_Background> <DRI_Background agreement="All_Equal">Similar method is presented in [Sloan et al. 2001] and [Kry et al. 2002].</DRI_Background> <DRI_Background agreement="All_Equal">The latter de-correlates the deformation displacements using principal component analysis, which reduces the memory requirements considerably.</DRI_Background> <DRI_Background agreement="All_Equal">The advantage of example based methods is that they capture the designed shape, including effects like muscle bulging.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">The drawback is the necessity of acquiring the example skins.</DRI_Background> <DRI_Background agreement="All_Equal">An interesting generalization of LBS is called multi-weight enveloping [Wang and Phillips 2002].</DRI_Background> <DRI_Background agreement="All_Equal">It introduces more parameters and therefore greater flexibility to the deformation algorithm.</DRI_Background> <DRI_Background agreement="All_Equal">Instead of one weight per influence (joint) as in LBS, the multiweight enveloping uses twelve.</DRI_Background> <DRI_Background agreement="All_Equal">These numerous parameters are derived from examples using the least squares optimization.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">The disadvantage is obvious: while the LBS models can be weighted manually by artists [Steed 2002], this is questionable with multiweight enveloping.</DRI_Background> <DRI_Background agreement="All_Equal">Tools that help animators to design the vertex weights are described in [Mohr et al. 2003].</DRI_Background> <DRI_Background agreement="All_Equal">This article is interesting also from the theoretical point of view, because it describes how to explore the space of all possible LBS deformations.</DRI_Background> <DRI_Background agreement="All_Equal">Another deformation algorithm [Bloomenthal 2002] uses a complex auxiliary structure – a medial.</DRI_Background> <DRI_Background agreement="All_Equal">An idea similar to spherical blend skinning (SBS) is bones blending proposed by [Kavan and Zára ˇ 2003].</DRI_Background> <DRI_Background agreement="All_Equal">However, bones blending is limited to vertices attached to only two joints.</DRI_Background> <DRI_Background agreement="All_Equal">In addition, it requires hand-tuning of special parameters.</DRI_Background> <DRI_Background agreement="All_Equal">Another algorithm removes the LBS artifacts by adding additional joints, and computes the vertex weights automatically using examples [Mohr and Gleicher 2003].</DRI_Background> <DRI_Background agreement="All_Equal">A recent skin deformation algorithm presented in [Magnenat-Thalmann et al. 2004] seems to give results competitive to SBS, although it is based on a different mathematical fundament [Alexa 2002].</DRI_Background> <DRI_Background agreement="All_Equal">However, this method is considerably slower than LBS and therefore [Magnenat-Thalmann et al. 2004] recommends to use rather the standard LBS if the joint rotations are small.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">To conclude, there are many methods correcting the problems of LBS, but none of them is superior to LBS in all aspects.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">As a result, the linear blend skinning is still widely used in many applications, in spite of the artifacts.</DRI_Background>
      
        <h1>2.1 Our Contribution</h1>
        <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Outcome">We observed that the artifacts of LBS are caused by the straightforward, linear interpolation of vertex positions.</DRI_Challenge> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Outcome">Intuitively, a linear blending is not suitable to capture deformations induced by skeleton, because their nature is rather spherical.</DRI_Challenge> <DRI_Approach ann2="DRI_Challenge_Goal" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">Our basic idea is to change the interpolation domain: we interpolate transformations itself instead of transformed vertex positions.</DRI_Approach> <DRI_Approach agreement="All_Equal">Because we consider transformations consisting of a translation and rotation, we suggest to use a quaternion representation.</DRI_Approach> <DRI_Challenge ann2="DRI_Approach" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_Outcome">The transition to non-linear interpolation domain is not elementary.</DRI_Challenge> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge_Goal">In order to achieve our goal, we cope with two main problems: determination of the center of rotation, and interpolation of multiple quaternions.</DRI_Challenge> <DRI_Challenge agreement="All_Equal">The first problem follows from the fact that the choice of the center of rotation influences the result of interpolation considerably.</DRI_Challenge> <DRI_Outcome_Contribution ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">We show how to compute a convenient center of rotation in real-time.</DRI_Outcome_Contribution> <DRI_Challenge agreement="All_Equal">The second problem is simple in the case of two quaternions [Shoemake 1985], but gets considerably harder for more than two rotations [Buss and Fillmore 2001; Park et al. 2002; Alexa 2002].</DRI_Challenge> <DRI_Approach agreement="All_Equal">Because the previous methods are not efficient enough for our purpose, we use a simple linear quaternion averaging.</DRI_Approach> <DRI_Outcome agreement="All_Equal">We justify both theoretically and experimentally that this solution is appropriate for our task (and probably for many others).</DRI_Outcome> <DRI_Outcome_Contribution agreement="All_Equal">Resolving those problems, we obtain a skin animation algorithm that deforms the mesh in much more plausible way then LBS.</DRI_Outcome_Contribution> <DRI_Outcome agreement="All_Equal">Because we change only the interpolation domain and not the input data, our program works with exactly the same models as LBS.</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">The proposed algorithm improves a deformed shape even of models that have been designed and carefully tuned for LBS.</DRI_Outcome_Contribution> <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">Considering the high speed and low memory demands of SBS, it provides an attractive alternative to classic LBS.</DRI_Outcome_Contribution>
      
      
        <h1>2.2 Conventions</h1>
        <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">Let us denote matrices by capital letters, while vectors and quaternions by bold.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">Vectors are considered column vectors, therefore a multiplication of vector v by matrix M is written as Mv.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">We do not introduce a different notation for the R 3 vectors and their homogeneous R 4 counterparts with last coordinate equal to 1.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">The same convention is used for matrices.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">We denote the dot product of two vectors v 1 , v 2 as (v 1 , v 2 ) and the norm v 1 as a shortcut for (v 1 , v 1 ).</DRI_Approach>
      
      
        <h1>3 Linear Blend Skinning</h1>
        <DRI_Background agreement="All_Equal">The input to LBS consists of a polygonal mesh representing the digital skin, a skeleton, and vertex weights for every vertex of the skin.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">The polygonal mesh and the skeleton are designed in a reference position, e.g. virtual characters are often posed in the da Vinci posture [Steed 2002].</DRI_Background> <DRI_Approach agreement="All_Equal">Let us label the joints by integer numbers, assigning zero to the root.</DRI_Approach> <DRI_Approach agreement="All_Equal">Each joint in the reference posture is associated with a homogeneous matrix, describing its position and orientation in the world coordinate system.</DRI_Approach> <DRI_Approach agreement="All_Equal">For j-th joint, we denote this matrix by A j , like ”absolute” (or reference) position.</DRI_Approach> <DRI_Approach agreement="All_Equal">This matrix is computed by multiplying all the transformations of individual joints in the chain from root to joint j.</DRI_Approach> <DRI_Approach agreement="All_Equal">To compute the shape of the deformed skin, we need yet another set of matrices, describing the position and orientation of joints in the actual, animated posture.</DRI_Approach> <DRI_Approach agreement="All_Equal">We call them F j , standing for the ”final” placement of joint j.</DRI_Approach> <DRI_Approach agreement="All_Equal">Matrices F j are computed in a similar way as the absolute matrices, but including the actual rotation of each joint in the chain (we do not consider translating and scaling joints).</DRI_Approach> <DRI_Approach ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">The most simple skin deformation algorithm computes v = F j A −1 j v where v is a vertex in the reference skin associated with joint j and v is its position in the deformed mesh.</DRI_Approach> <DRI_Approach ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">The interpretation is following: the first matrix A −1 j transforms v to the position with joint j’s coordinate system aligned to the world coordinate system.</DRI_Approach> <DRI_Approach ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">The following transformation F j returns the vertex to its current position induced by the animated skeleton.</DRI_Approach> <DRI_Approach agreement="All_Equal">Because these transformations usually occur together, we define the ”complete” matrix C j = F j A −1 j .</DRI_Approach> <DRI_Background agreement="All_Equal">Some older computer games animated characters in this way, even though it does not produce nice, smooth deformations.</DRI_Background> <DRI_Approach ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">The linear blend skinning allows assignment of one vertex to multiple bones.</DRI_Approach> <DRI_Approach agreement="All_Equal">Assume that vertex v is attached to joints j 1 , . . . , j n with weights w 1 , . . . , w n .</DRI_Approach> <DRI_Approach agreement="All_Equal">The weights are coefficients of a convex combination, i.e. non-negative and ∑ n i=1 w i = 1.</DRI_Approach> <DRI_Approach agreement="All_Equal">The weight w i represents the amount of influence of joint j i .</DRI_Approach> <Sentence agreement="All_Equal">The vertex position in the mesh deformed by LBS is then computed as</Sentence>
        
          1
          n v = ∑ w i C j i v i=1
        
        <Sentence agreement="All_Equal">that is to say, making a convex combination of individual vertex transformations.</Sentence> <DRI_Approach agreement="All_Equal">For example if n = 2 then vertex v lies on the line segment connecting C j 1 v and C j 2 v.</DRI_Approach> <DRI_Approach agreement="All_Equal">The actual position on the segment is given by weight w 1 (or w 2 , because w 1 +w 2 = 1).</DRI_Approach> <DRI_Approach agreement="All_Equal">As explained in the next section, the SBS works on a circular arc instead of segment, see Figure 1 .</DRI_Approach> <DRI_Approach agreement="All_Equal">If the joint rotations are large, the LBS produces non-natural deformations.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge">In the extremal case of rotation by 180 degrees, the skin can collapse to a single point.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge">It is the notorious ”candy-wrapper” artifact, which is demonstrated in Figure 2 .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">The right shoulder of the model is twisted by 180 degrees, while the left shoulder is left in the reference pose.</DRI_Approach> <DRI_Approach ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">To understand why this undesirable effect occurs, it is sufficient to re-arrange the equation (1)</DRI_Approach>
        mesh bone joint j 1 j 2 vertex v C j 2 v C j 1 v LBS workspace SBS workspace
        
          Figure 1: The set of possible results of LBS is a line segment, while SBS gives a circular arc.
        
        
          2
          n v = ∑ w i C j i v i=1
        
        <DRI_Approach agreement="All_Equal">This formula is less efficient, because it blends matrices instead of vectors, but gives us a valuable insight.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">It is well known that the component-wise interpolation of matrices produces odd results: it does not preserve the orthogonality of the rotational part of the matrix.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">In some situations, it does not preserve even the rank of the interpolated matrices.</DRI_Approach> <DRI_Challenge ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">This is exactly what happens in the ”candywrapper” problem: the single point the skin collapses to is a result of transformation by a singular matrix.</DRI_Challenge> <DRI_Challenge ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">A similar defect is visible also in the proximity of the singular configuration.</DRI_Challenge> <DRI_Challenge ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">Although the matrix is regular, it involves a non-uniform scaling and skewing, which is responsible for the loss of volume of the deformed skin even for small rotations.</DRI_Challenge>
      
      
        <h1>4 Spherical Blend Skinning</h1>
        <DRI_Challenge_Goal ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge_Goal" ann3="DRI_Challenge_Goal">Instead of trying to correct the bad results of LBS, we propose to change the interpolation method in (2).</DRI_Challenge_Goal> <DRI_Approach agreement="All_Equal">We focus on the interpolation of rotations – the linear interpolation of the translation part of C j i matrices is all right.</DRI_Approach> <DRI_Approach agreement="All_Equal">An established interpolation of two rotations is spherical linear interpolation (SLERP) [Shoemake 1985].</DRI_Approach> <DRI_Approach agreement="All_Equal">Its key of success is the use of quaternions to represent rotations.</DRI_Approach> <DRI_Approach agreement="All_Equal">Unfortunately, it is not possible to simply replace matrices C j i in (2) with corresponding pairs quaternion-translation.</DRI_Approach> <DRI_Approach agreement="All_Equal">One of the problems is that the linear interpolation of quaternions is not equivalent to SLERP.</DRI_Approach> <DRI_Approach agreement="All_Equal">However, this is not the most serious difficulty, and we address it in section 4.1.</DRI_Approach> <DRI_Challenge_Goal ann2="DRI_Approach" agreement="3diff" ann1="DRI_Challenge_Goal" ann3="DRI_Challenge">The more important problem is to compute a convenient center of the interpolated rotations.</DRI_Challenge_Goal> <DRI_Challenge ann2="DRI_Approach" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_Outcome">We show that this is really an important problem on an example of human arm.</DRI_Challenge> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">Consider that the arm geometry is influenced by two joints j 1 and j 2 , such that j 1 is a parent of j 2 , as in Figure 1 .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">The transformation of the whole mesh by C j 1 is illustrated in the top row of Figure 3 and the transformation of the same geometry by C j 2 in the bottom row (note that the results are identical in both columns of these rows).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">The rows in the middle show the progress of interpolation between C j 1 to C j 2 .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">The only difference between the two columns in Figure 3 is in the choice of the center of rotation.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">In the left column, the rotation center r c is set to the translation part of matrix A j 2 (the position of joint j 2 in the reference posture).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">Note that C j 1 r c = C j 2 r c , therefore also the transformed rotation center is constant during the interpolation.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">In the right column of the figure, the rotation center r c is set to the translation part of A j 1 .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">Because C j 1 r c = C j 2 r c , the transformed rotation center is linearly interpolated from C j 1 r c to C j 2 r c .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">By comparison with the starting mesh (drawn gray in each frame), it is obvious that the center of rotation choice in the left column is much more advantageous.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">In this case, the interpolation of every single point is a circular arc (as in Figure 1), whereas a disturbing drift is inherent to any other choice of rotation center (such as r c ).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">Unfortunately, the condition of zero translation cannot be always satisfied, typically for more than two influencing joints.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">But even if the vertex is attached to only two joints k and l that are not neighbours of each other, some translation may be inevitable.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">For example consider that there is no relative rotation between C k and C l , but there is a relative translation induced by the joints in the chain between k and l.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Approach">Clearly no choice of the center of rotation can avoid this translation, because the rotation is identity.</DRI_Approach> <DRI_Approach agreement="All_Equal">Anyway, it is possible to define the rotation center as the point whose transformations by associated matrices are as close as possible.</DRI_Approach> <DRI_Approach agreement="All_Equal">This minimizes the drift and works even if the vertex is assigned to n joints j 1 , . . . , j n .</DRI_Approach> <Sentence agreement="All_Equal">We find the center of rotation r c as the</Sentence>
        
          Figure 2: Up – an extreme shoulder twist deformed by LBS, down – the same posture deformed by SBS
        
        C j 1 C j 1 C j 1 r c C j 1 r c
        C j 2 C j 2 C j 2 r c C j 2 r c
        
          Figure 3: The correct center of rotation is chosen in the left column, while the sub-optimal in the right column. In the middle rows, notice the difference of the elbow position with respect to the original skin.
        
        <Sentence agreement="All_Equal">least-squares solution of the system of n 2 linear vector equations C a r c = C b r c , a &lt; b, a, b ∈ { j 1 , . . . , j n } Each homogeneous matrix C i has structure C i = C 0 i rot T C 1 tr i
        where C i rot is a 3 × 3 orthogonal matrix and C tr i is a translation vector.</Sentence> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">This enables us to re-write the linear system to C a rot r c + C tr a = C b rot r c + C tr b (C a rot −C b rot )r c = C tr b − C tr a If we stack all these equations to one matrix D and the right-hand sides to vector e, we can write the whole system as Dr c = e where D is a 3 n 2 × 3 matrix, r c is a 3-dimensional unknown vector and e is 3 2 n -dimensional vector.</Sentence> <DRI_Approach agreement="All_Equal">In general, we cannot make any assumptions about the rank of matrix D, which can vary from 0 to 3 (consider for example n = 2 and C j 1 = C j 2 ).</DRI_Approach> <DRI_Approach agreement="All_Equal">We search the optimal solution r c in the least-squares sense.</DRI_Approach> <DRI_Approach agreement="All_Equal">If there are multiple solutions giving the minimal Dr c − e , the r c with the minimal norm is chosen.</DRI_Approach> <DRI_Approach agreement="All_Equal">This can be done in a robust way using the singular value decomposition (SVD), followed by computation of pseudo-inverse matrix.</DRI_Approach> <DRI_Approach agreement="All_Equal">To perform these computations, we use the LAPACK software [Anderson et al. 1999].</DRI_Approach> <DRI_Approach agreement="All_Equal">Even though LAPACK routines are efficient, computation of the center of rotation per each vertex would not result in a real-time algorithm.</DRI_Approach> <DRI_Approach agreement="All_Equal">Fortunately, the center of rotation depends only on the transformations of the joints j 1 , . . . , j n and not the vertex itself.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Therefore, if we encounter another vertex assigned to the same set of joints j 1 , . . . , j n , we can re-use the center of rotation computed formerly (cached).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Moreover, if there is only one, or two neighboring joints that influence the vertex, we can determine the center of rotation precisely (as indicated in the beginning of this section) and omit the SVD computation at all.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">It turns out that the number of different non-trivial joint sets, and therefore the number of running the SVD, is surprisingly small for common models – about several tens.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">This enables the real-time performance.</DRI_Approach>
      
      
        <h1>4.1 Interpolation of Multiple Rotations</h1>
        <DRI_Background agreement="All_Equal">As mentioned in the introduction, the interpolation of multiple rotations has already received some attention [Buss and Fillmore 2001; Park et al. 2002] as well as interpolation of multiple general transformations [Alexa 2002].</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Unfortunately, all these methods are substantially slower then the simple linear interpolation used in LBS.</DRI_Background> <DRI_Challenge_Goal agreement="All_Equal">Since our goal is an algorithm with comparable time complexity as LBS, we propose an approximate but fast linear quaternion blending.</DRI_Challenge_Goal> <DRI_Approach agreement="All_Equal">For the case of two rotations, we compare our method with the established SLERP.</DRI_Approach> <DRI_Approach agreement="All_Equal">Recall that a rotation around axis a (unit length vector) with angle 2 α corresponds to quaternion q = cos α + a sin α .</DRI_Approach> <DRI_Approach agreement="All_Equal">However, this correspondence is not unique, because both quaternions q and −q represent the same rotation.</DRI_Approach> <DRI_Approach agreement="All_Equal">The SLERP of two unit quaternions p, q assumes that their dot product (p, q) ≥ 0.</DRI_Approach> <DRI_Approach agreement="All_Equal">If the dot product (p, q) &lt; 0, we use −p instead of p, which is possible because both p and −p represent the same rotation.</DRI_Approach> <DRI_Approach agreement="All_Equal">The SLERP of p, q with interpolation parameter t ∈ 0, 1 is given by the following formula, see for example [Eberly 2001].</DRI_Approach>
        
          3
          sin((1 − t) θ )p + sin(t θ )q s(t; p, q) = sin θ
        
        <Sentence agreement="All_Equal">where θ is the angle inclined by quaternions p, q, i.e. cos θ = (p, q).</Sentence> <Sentence agreement="All_Equal">The linear interpolation of quaternions (QLERP) is computed as</Sentence>
        
          4
          (1 − t)p + tq l(t; p, q) = (1 − t)p + tq
        
        <DRI_Approach ann2="Sentence" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">The difference to SLERP is obvious: QLERP interpolates along the shortest segment, and then projects to arc, which does not result in the uniform interpolation of the arc.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">In spite of this, we claim that QLERP is sufficient for our task.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">In order to justify this statement, we face an interesting question by itself: how big can be the difference between QLERP and SLERP for the same input rotations?</DRI_Approach> <Sentence ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="Sentence">For t = 0, both QLERP and SLERP return of course p. For t &gt; 0, we can imagine that both QLERP and SLERP work by concatenating p with some rotation (multiplying p with some quaternion).</Sentence> <DRI_Approach agreement="All_Equal">For SLERP, we denote this quaternion as r s (t).</DRI_Approach> <Sentence agreement="All_Equal">It can be expressed as p ∗ s(t; p, q), because pr s (t) = pp ∗ s(t; p, q) = s(t; p, q) The rotation r s (t) can be written out as</Sentence>
        
          5
          r s (t) = p ∗ s(t; p, q) = sin((1 − t) θ sin )1 + θ sin(t θ )p q
        
        <DRI_Approach agreement="All_Equal">The quaternion 1 represents the identity (zero angle rotation).</DRI_Approach> <DRI_Approach agreement="All_Equal">From the definition of quaternion multiplication it can be seen that the real part of p ∗ q equals (p, q) = cos θ .</DRI_Approach> <DRI_Approach agreement="All_Equal">Since p ∗ q is a unit quaternion, we can express it as p ∗ q = cos θ + u sin θ for some axis of rotation u.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">If we substitute this into equation (5), we obtain sin((1 − t) θ ) + sin(t θ ) cos θ r s (t) = sin θ + u sin(t θ ) which means that the direction of the axis u is independent on t.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Let us examine the rotation r l (t) following p in QLERP: r l (t) = p ∗ l(t; p, q) = (1 (1 − − t)1 t)p + + tp tq ∗ q = (1 − t + t cos θ ) t sin θ = + u (1 − t)p + tq (1 − t)p + tq which shows that the axis of rotation has the same direction.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">We can conclude with an important property: the SLERP can be written as pr s (t) and QLERP as pr l (t), where the rotations r s (t) and r l (t) have the same axis.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Moreover, this axis is constant, i.e. independent on the interpolation parameter t.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">It follows that the only difference between QLERP and SLERP is in the angle of rotations r s (t) and r l (t).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Note that both r s (t) and r l (t) have a form of linear combination of quaternions 1 and p ∗ q.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">It means that the results of both r s (t) and r l (t) always end up in certain 2D subspace of R 4 .</DRI_Approach> <DRI_Approach agreement="All_Equal">We can restrict our attention to this subspace (the linear hull of 1 and p ∗ q).</DRI_Approach> <DRI_Approach agreement="All_Equal">Since SLERP assumes cos θ = (p, q) ≥ 0, the angle θ cannot exceed π /2.</DRI_Approach> <DRI_Approach agreement="All_Equal">To obtain an upper bound of the maximal difference in the angle, we consider the extremal case with θ = π /2, depicted in Figure 4 .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="Sentence">The angle α (t) on the picture can be computed by atan, and β (t) by simple linear interpolation of the right angle, which yields the difference function t π d(t) = α (t) − β (t) = atan − t 1 − t 2 It remains to find the extremes of d(t) on the interval 0, 1 .</DRI_Approach> <DRI_Approach agreement="All_Equal">The elementary mathematical analysis discovers the global extremes in points 1/2 ± (1/ π − 1/4).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The absolute value of d(t) in these points is approximately 0.071 radians (4.07 degrees).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">As mentioned in the introduction of this section the angle of rotation is twice the angle inclined by quaternions.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">To conclude: both SLERP and QLERP interpolate by multiplying the first quaternion with a rotation with the same, fixed axis.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The difference between SLERP and QLERP is only in the angle of this rotation, and is strictly less then 0.143 radians (8.15 degrees) for any interpolation parameter t ∈ 0, 1 .</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">This is an upper bound; practical results are much smaller and could hardly cause an observable defect in the deformed skin.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The big advantage of QLERP is that it can be easily generalized to interpolate multiple rotations – it suffices to make a convex combination and re-normalization of multiple quaternions.</DRI_Approach>
        1 SLERP QLERP t a (t) b (t) 1-t 1
        
          Figure 4: The difference between QLERP angle α (t) and SLERP β (t)
        
      
      
        <h1>4.2 Algorithm Overview</h1>
        <DRI_Approach agreement="All_Equal">Now we have prepared all the ingredients to describe how the SBS algorithm works.</DRI_Approach> <DRI_Approach agreement="All_Equal">The task is to transform a vertex v influenced by joints j 1 , . . . , j n with convex weights W = (w 1 , . . . , w n ) to its position v in the animated skin.</DRI_Approach> <DRI_Approach agreement="All_Equal">In order to obtain an appealing deformation, it is necessary to respect the computed center of rotation r c .</DRI_Approach> <DRI_Approach agreement="All_Equal">To achieve this, we extend the QLERP scheme to homogeneous matrices C j i .</DRI_Approach> <Sentence agreement="All_Equal">We denote the interpolation of matrices C j i with weights W as</Sentence>
        
          6
          Q m q(W ;C j 1 , . . . ,C j n ) = 0 T 1
        
        <Sentence agreement="All_Equal">and compute Q and m as follows.</Sentence> <DRI_Approach agreement="All_Equal">First, the rotation submatrices C rot j i are converted to quaternions q j i .</DRI_Approach> <DRI_Approach agreement="All_Equal">One of them, for example q j 1 , is chosen as pivot.</DRI_Approach> <DRI_Approach agreement="All_Equal">If (q j 1 , q j i ) &lt; 0 for any i = 2, . . . , n, we replace q j i with −q j i (by analogy to SLERP).</DRI_Approach> <Sentence agreement="All_Equal">Then the QLERP computes s = w 1 q j 1 + .</Sentence> . . <Sentence agreement="All_Equal">+ w n q j n , which is subsequently normalized to s n = s/ s .</Sentence> <Sentence agreement="All_Equal">Finally, s n is converted to the rotation matrix Q. The translation part is just linearly interpolated, m = ∑ n i=1 w i C tr j i .</Sentence> <DRI_Approach agreement="All_Equal">In order to change the center of rotation from the origin to r c , we define a homogeneous matrix
        T = 0 I T r 1 c (7)
        where I is a 3 × 3 identity matrix.</DRI_Approach> <Sentence agreement="All_Equal">Then the interpolation of homogeneous matrices with respect to the center of rotation r c can be written as</Sentence>
        
          8
          T q(W ; T −1 C j 1 T, . . . , T −1 C j n T )T −1
        
        <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Note that the shift of the center of rotation does not influence the interpolated rotation – it manifests only in the translation part.</DRI_Approach> <DRI_Approach ann2="Sentence" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">The desired transformation of vertex v is v = T q(W ; T −1 C j 1 T, . . . , T −1 C j n T )T −1 v</DRI_Approach>
        
          9
          n = Q(v − r c ) + ∑ w i C j i r c i=1
        
        <Sentence agreement="All_Equal">A detailed derivation of this formula can be found in appendix A. The latter addend represents the translation induced by the new center of rotation.</Sentence> <DRI_Approach agreement="All_Equal">The equation (9) has to be evaluated once per each vertex, and therefore should be as efficient as possible.</DRI_Approach> <DRI_Approach agreement="All_Equal">The basic optimization is to pre-compute the quaternions q j i , because they do not depend on the actual vertex – only on the joint’s transformation, similarly as the rotation centers r c .</DRI_Approach> <DRI_Approach agreement="All_Equal">Nonetheless, QLERP has to be executed for each vertex, since weights w 1 , . . . , w n can vary.</DRI_Approach> <DRI_Approach agreement="All_Equal">In order to challenge the speed of LBS, we apply a following trick.</DRI_Approach> <DRI_Approach agreement="All_Equal">The vertex v can be represented by a quaternion with zero real part.</DRI_Approach> <DRI_Approach agreement="All_Equal">In this representation, its rotation by quaternion q can be expressed as q vq ∗ , which is a quaternion with zero real part as well [Eberly 2001].</DRI_Approach> <Sentence agreement="All_Equal">Although this expression is not efficient for computation (because of slow quaternion multiplication), it enables us to write out the rotation of v by quaternion s n as s n vs n ∗ = s 1 2 svs ∗ = (s, 1 s) svs ∗ This suggests to convert already the quaternion s to matrix Q and normalize subsequently by dividing (s, s).</Sentence> <DRI_Approach agreement="All_Equal">Therefore, we can compute the Q matrix from (9) as Q = (s,s) Q and save the sqrt operation.</DRI_Approach> <DRI_Approach agreement="All_Equal">Some attention must be paid because standard routines for quaternion to matrix conversion assume a unit-length quaternion.</DRI_Approach> <Sentence agreement="All_Equal">The conversion of an arbitrary length q = w + xi + y j + zk leads to the following matrix: ⎛ ⎞ x 2 + w 2 − y 2 − z 2 2xy − 2wz 2xz + 2wy ⎝ 2xy + 2wz y 2 + w 2 − x 2 − z 2 2yz − 2wx ⎠ 2xz − 2wy 2yz + 2wx z 2 + w 2 − x 2 − y 2 Vertex normal v n is transformed in a similar way as vertex position, but ignoring the translation v n = Qv n Using the formula (9) we can verify our previous intuitive thinking.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">First, if we substitute r c in place of v, no rotation occurs, which means that r c is indeed a center of rotation.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Second, if n = 2 and C j 1 r c = C j 2 r c (as in the beginning of section 4), the translation part becomes w 1 C j 1 r c + w 2 C j 2 r c = (w 1 + w 2 )C j 1 r c = C j 1 r c which is independent of interpolation parameters (weights), i.e. the translation during interpolation is constant indeed.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Third, the equation (9) is nothing but a generalization of LBS to an arbitrary method of rotation interpolation.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The choice of QLERP is not important for (9), the matrix Q can be replaced by matrix resulting from any other interpolation scheme, such as [Buss and Fillmore 2001].</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">If we substitute Q = ∑ w i C rot j i , i.e. a simple linear combination of rotation matrices, we obtain v = Q(v − r c ) + ∑ w i C j i r c = ∑ w i C rot j i v − ∑ w i C rot j i r c + ∑ w i C rot j i r c + ∑ w i C tr j i = ∑ w i C rot j i v + ∑ w i C tr j i = ∑ w i C j i v which is exactly the LBS equation (1).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">This also shows that LBS is a special case, which is independent of the center of rotation.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The whole algorithm can be summarized in the following steps:</DRI_Approach>
        
          Figure 5: 3D models used for testing
        
        
          
            
              
                
                  
                   Hand
                   Woman
                   Creature
                
              
              
                
                   vertices
                   2402
                   3356
                   6802
                
                
                   triangles
                   4800
                   5205
                   13590
                
                
                   joints
                   23
                   78
                   56
                
              
            
          
          Hand Woman Creature vertices 2402 3356 6802 triangles 4800 5205 13590 joints 23 78 56
          Table 1: Complexities of example models
        
        <Sentence agreement="All_Equal">• compute matrices C i for all joints and convert their rotation parts to quaternions q i • for each vertex v influenced by joints j 1 , . . . , j n – compute (or re-use a cached) center of rotation r c according to section 4 – blend quaternions q j 1 , . . . q j n using QLERP and convert the result to matrix Q – compute the position of vertex v in the deformed skin using the equation (9)</Sentence>
      
      
        <h1>5 Results and Comparison</h1>
        <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">We tested the SBS algorithm on three models, see Figure 5 and Table 1.</DRI_Approach> <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">We compare the shape of the deformed skin on the model of woman, because human eye is most sensitive to the deformations of human body.</DRI_Approach> <DRI_Unspecified ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">Figure 6 presents results of LBS and SBS executed on the same posture of the model.</DRI_Unspecified> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">Another example has been presented already in Figure 2 .</DRI_Outcome> <DRI_Outcome agreement="All_Equal">For small deformations, both algorithms produce similar results, as in the second row of Figure 6 (although a small loss of volume is noticeable even there).</DRI_Outcome> <DRI_Outcome agreement="All_Equal">It is remarkable that the results of SBS are better even though the models have been optimised to work with the LBS algorithm.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Unspecified">The performance of both algorithms is compared in Table 2 .</DRI_Outcome> <DRI_Outcome agreement="All_Equal">The measured value is an average time in milliseconds necessary to deform one model on a 2.5GHz Athlon PC (rendering time not included).</DRI_Outcome> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Unspecified">In the last row of the table the number of different nontrivial joint sets is reported (trivial joint set consists of only one joint</Sentence>
        
          Figure 6:
        
        Comparison of deformations by LBS (left) and SBS
        (right)
        <Sentence agreement="All_Equal">or two neighboring joints).</Sentence> <DRI_Outcome agreement="All_Equal">Put in another way, it is exactly the number of singular-value decompositions performed by the SBS algorithm.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">This number participates considerably on the difference between times for LBS and SBS.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Theoretically, the number of different non-trivial joint sets could be very high.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">Fortunately, this number is surprisingly small in practice, because the joint influences tend to be local (e.g. it is unlikely to find vertices influenced by both left and right wrist).</DRI_Outcome> <DRI_Outcome agreement="All_Equal">The additional memory needed for SBS is dominated by caching the computed centers of rotation.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">However, this amount of memory is negligible, considering the number of different non-trivial joint sets.</DRI_Outcome> <DRI_Approach ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">In order to test the accuracy of QLERP, we experimented with spherical weighted averages presented in [Buss and Fillmore 2001].</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">The algorithm proposed in [Buss and Fillmore 2001] behaves like SLERP for the case of two rotations (in contrast to QLERP, which only approximates SLERP results).</DRI_Outcome> <DRI_Outcome agreement="All_Equal">On the one hand, the difference in the deformed skin was barely observable, according to the results from section 4.1.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">On the other hand, the increase in the execution time was quite substantial.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">For the woman model, the time increased from original 4.54ms to 22.74ms.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">This only confirmed our choice of QLERP.</DRI_Outcome>
        
          
            
              
                
                  
                   Hand
                   Woman
                   Creature
                
              
              
                
                   LBS time
                   3.28
                   3.59
                   9.0
                
                
                   SBS time
                   4.43
                   4.54
                   11.37
                
                
                   SVD executions
                   38
                   37
                   56
                
              
            
          
          Hand Woman Creature LBS time 3.28 3.59 9.0 SBS time 4.43 4.54 11.37 SVD executions 38 37 56
          Table 2: First two rows: run-time of LBS and SBS algorithms in milliseconds; last row: number of SVD executions
        
      
      
        <h1>5.1 Conclusion and Future Work</h1>
        <DRI_Outcome agreement="All_Equal">The proposed skin deformation system is by no means perfect; it cannot compete with complex, layered models.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">However, the SBS algorithm offers reasonable price for elimination of the notorious LBS artifacts.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">The time and memory complexity of both algorithms is comparable.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">The overhead of replacing an existing LBS implementation by SBS is minimal, because the input data, as well as the internal data structures, are the same.</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">In contrast to other methods, the SBS does not need any additional information, such as the example skins.</DRI_Outcome_Contribution> <DRI_FutureWork agreement="All_Equal">The presented algorithm opens many questions and suggests several directions of future work.</DRI_FutureWork> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">First of all, we worked only with vertex weights optimised for LBS.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">These weights are designed to suppress the LBS artifacts, even though they cannot remove them.</DRI_Outcome> <DRI_FutureWork agreement="All_Equal">It would be interesting to find out how much can be the SBS results improved by a set of weights especially designed for SBS.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">In order to accomplish this, a tool to explore the space of SBS deformations would help considerably.</DRI_FutureWork> <DRI_FutureWork ann2="DRI_Approach" agreement="3diff" ann1="DRI_FutureWork" ann3="DRI_Background">This tool has been presented for LBS in [Mohr et al. 2003], but the situation of SBS is somewhat more complex, because our interpolation method is non-linear.</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">Similarly, it would be possible to estimate the SBS vertex weights from examples, as was done for LBS in [Mohr and Gleicher 2003].</DRI_FutureWork> <DRI_FutureWork agreement="All_Equal">This could also cover additional effects like muscle bulging.</DRI_FutureWork>
      
      
        <h1>6 Acknowledgments</h1>
        <DRI_Unspecified agreement="All_Equal">This work has been partly supported by the Ministry of Education, Youth and Sports of the Czech Republic under research program No.Y04/98:212300014 (Research in the area of information technologies and communications).</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">We thank to Samuel Buss for providing the algorithm for spherical weighted averages [Buss and Fillmore 2001] and to LAPACK developers for their software.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">We would also like to thank to Jaroslav Seman cı k and the anonymous reviewers for valuable comments and to Adam J. Sporka for help with the accompanying video.</DRI_Unspecified>
      
      
        <h1>A Interpolation of Rotations with an Arbitrary Center</h1>
        <DRI_Approach ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">In this appendix we derive the formula (9), which describes the interpolation of rotations with respect to r c – a custom center of rotation.</DRI_Approach> <DRI_Approach agreement="All_Equal">Let us denote by K the coordinate system with origin in r c and identical basis vectors as the world coordinate system.</DRI_Approach> <DRI_Approach agreement="All_Equal">Then
        the matrix T (7) can be interpreted as a transformation from K to the world coordinate system.</DRI_Approach> <Sentence agreement="All_Equal">By analogy, the inverse matrix T −1 = 0 I T −r 1 c
        represents the transformation from the world coordinate system to K. It follows that T −1 C j i T is the transformation C j i expressed with respect to K. By interpolating these matrices with QLERP q(W ; T −1 C j 1 T, . . . , T −1 C j n T ) we obtain a matrix working also on vectors in K coordinates.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="Sentence" ann3="DRI_Approach">We can express this matrix with respect to the world coordinate system easily T q(W ; T −1 C j 1 T, . . . , T −1 C j n T )T −1 which is exactly the formula (8).</DRI_Approach> <DRI_Approach agreement="All_Equal">Recall that the matrix C j i has structure C j i = C 0 rot j T i C 1 tr j i
        which enables us to write out T −1 C j i T = C 0 rot j T i C j i r c 1 − r c
        as can be simply verified.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Please note that the change of the coordinate system did not influence the rotation part C rot j i at all.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Therefore the result of QLERP will be, according to equation (6)
        q(W ; T −1 C j 1 T, . . . , T −1 C j n T ) = 0 Q T −r c + ∑ i=1 n 1 w i C j i r c
        where Q stands for the interpolation of pure rotations, computed as indicated in section 4.2.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Using T −1 v = v − r c and T x = x + r c , we see that v = T q(W ; T −1 C j 1 T, . . . , T −1 C j n T )T −1 v = T 0 Q T −r c + ∑ i=1 n 1 w i C j i r c v − 1 r c n = Q(v − r c ) + ∑ w i C j i r c i=1
        is true for any vector v.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">This is exactly the equation (9).</DRI_Approach>
      
      
        <h1>References</h1>
        
          A LEXA , M. 2002. Linear combination of transformations. In SIGGRAPH ’02: Proceedings of the 29th annual conference on Computer graphics and interactive techniques, ACM Press, 380–387.
          A NDERSON , E., B AI , Z., B ISCHOF , C., B LACKFORD , S., D EM MEL , J., D ONGARRA , J., D U C ROZ , J., G REENBAUM , A., H AMMARLING , S., M C K ENNEY , A., AND S ORENSEN , D. 1999. LAPACK Users’ Guide, third ed. Society for Industrial and Applied Mathematics, Philadelphia, PA.
          B LOOMENTHAL , J. 2002. Medial-based vertex deformation. In Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium on Computer animation, ACM Press, 147–151.
          B USS , S. R., AND F ILLMORE , J. P. 2001. Spherical averages and applications to spherical splines and interpolation. ACM Trans. Graph. 20, 2, 95–126.
          E BERLY , D. 2001. 3D game engine design: a practical approach to real-time computer graphics. Morgan Kaufmann Publishers Inc.
          K AVAN , L., AND Z ˇ ARA  ́ , J. 2003. Real-time skin deformation with bones blending. In WSCG Short Papers Proceedings.
          K RY , P. G., J AMES , D. L., AND P AI , D. K. 2002. Eigenskin: real time large deformation character skinning in hardware. In Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium on Computer animation, ACM Press, 153–159.
          L ANDER , J. 1998. Skin them bones: Game programming for the web generation. Game Developer Magazine (May), 11–16.
          L ANDER , J. 1999. Over my dead, polygonal body. Game Developer Magazine (October), 17–22.
          L EWIS , J. P., C ORDNER , M., AND F ONG , N. 2000. Pose space deformation: a unified approach to shape interpolation and skeleton-driven deformation. In Proceedings of the 27th annual conference on Computer graphics and interactive techniques, ACM Press/Addison-Wesley Publishing Co., 165–172.
          M AGNENAT -T HALMANN , N., L APERRI È RE , R., AND T HAL MANN , D. 1988. Joint-dependent local deformations for hand animation and object grasping. In Proceedings on Graphics interface ’88, Canadian Information Processing Society, 26–33.
          M AGNENAT -T HALMANN , N., C ORDIER , F., S EO , H., AND P A PAGIANAKIS , G. 2004. Modeling of bodies and clothes for virtual environments. In CW ’04: Proceedings of the 2004 International Conference on Cyberworlds (CW’04), IEEE Computer Society, 201–208.
          M OHR , A., AND G LEICHER , M. 2003. Building efficient, accurate character skins from examples. ACM Trans. Graph. 22, 3, 562– 568.
          M OHR , A., T OKHEIM , L., AND G LEICHER , M. 2003. Direct manipulation of interactive character skins. In Proceedings of the 2003 symposium on Interactive 3D graphics, ACM Press, 27–30.
          P ARK , S. I., S HIN , H. J., AND S HIN , S. Y. 2002. On-line locomotion generation based on motion blending. In Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium on Computer animation, ACM Press, 105–111.
          S HOEMAKE , K. 1985. Animating rotation with quaternion curves. In Proceedings of the 12th annual conference on Computer graphics and interactive techniques, ACM Press, 245–254.
          S LOAN , P.-P. J., R OSE , III, C. F., AND C OHEN , M. F. 2001. Shape by example. In Proceedings of the 2001 symposium on Interactive 3D graphics, ACM Press, 135–143.
          S TEED , P. 2002. Animating Real-Time Game Characters with CDROM. Charles River Media, Inc.
          W ANG , X. C., AND P HILLIPS , C. 2002. Multi-weight enveloping: least-squares approximation techniques for skin animation. In Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium on Computer animation, ACM Press, 129–138.
          W EBER , J. 2000. Run-time skin deformation. In Proceedings of Game Developers Conference.
        
      
    
  
</Document>