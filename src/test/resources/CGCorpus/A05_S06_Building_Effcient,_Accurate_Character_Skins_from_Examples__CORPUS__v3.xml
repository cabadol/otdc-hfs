<?xml version="1.0" encoding="UTF-8" ?>
<Document corpusVersion="3" name="A05_S06_Building_Effcient,_Accurate_Character_Skins_from_Examples">
  
    4d7508619e6c2edec7350f85a067113fef474375b28592cf953cecd2f37b95ff
    3wx9
    http://dx.doi.org/10.1145/1201775.882308
  
  
    
      To appear at SIGGRAPH 2003
      
        <article-title>Building Efficient, Accurate Character Skins from Examples</article-title>
      
      
        
          Alex Mohr ∗ Michael Gleicher University of Wisconsin
        
        
          Madison
        
      
      
        
        Figure 1: Several still frames of our character from Figure 9 in a new animation sequence.
      
      <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">Good character animation requires convincing skin deformations including subtleties and details like muscle bulges.</DRI_Challenge> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Such effects are typically created in commercial animation packages which provide very general and powerful tools.</DRI_Background> <DRI_Challenge agreement="All_Equal">While these systems are convenient and flexible for artists, the generality often leads to characters that are slow to compute or that require a substantial amount of memory and thus cannot be used in interactive systems.</DRI_Challenge> <DRI_Challenge agreement="All_Equal">Instead, interactive systems restrict artists to a specific character deformation model which is fast and memory efficient but is notoriously difficult to author and can suffer from many deformation artifacts.</DRI_Challenge> <DRI_Outcome_Contribution agreement="All_Equal">This paper presents an automated framework that allows character artists to use the full complement of tools in high-end systems to create characters for interactive systems.</DRI_Outcome_Contribution> <DRI_Approach agreement="All_Equal">Our method starts with an arbitrarily rigged character in an animation system.</DRI_Approach> <DRI_Approach agreement="All_Equal">A set of examples is exported, consisting of skeleton configurations paired with the deformed geometry as static meshes.</DRI_Approach> <DRI_Approach ann2="DRI_Outcome" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome_Contribution">Using these examples, we fit the parameters of a deformation model that best approximates the original data yet remains fast to compute and compact in memory.</DRI_Approach>
	<h2>Keywords: </h2>Interactive, Skin, Approximation
    
    
      
        <h1>1 Introduction</h1>
      
      <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">To be believable, animated characters must deform in plausible ways as they move.</DRI_Challenge> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">It is possible to accomplish this by having an artist sculpt an entire character mesh by hand for every frame of an animation sequence, but this is impractical.</DRI_Challenge> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">Instead, animators typi- cally manipulate an underlying hierarchical skeleton.</DRI_Challenge> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">The character mesh geometry must then be attached to the underlying skeleton so that as the skeleton deforms, the mesh also deforms appropriately.</DRI_Background> <DRI_Background agreement="All_Equal">This attachment of model geometry to an underlying skeleton is called a “skin” and can be viewed as a function that maps from the skeletal parameters to a deformation field.</DRI_Background> <DRI_Background agreement="All_Equal">There are two fundamental aspects of skin creation—authoring and computation.</DRI_Background> <DRI_Background agreement="All_Equal">Skin authoring refers to how artists use tool sets to describe the behavior of skin geometry as the skeleton moves.</DRI_Background> <DRI_Background agreement="All_Equal">Skin computation refers to the method by which the deformed mesh geometry is evaluated for display at some skeleton configuration.</DRI_Background> <DRI_Background agreement="All_Equal">For high-end applications, the authoring methods drive skin creation while for interactive systems, computation methods dominate.</DRI_Background> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">For high-end applications such as film, the visual fidelity of characters is paramount, so artists require flexibility and control in skin authoring.</DRI_Challenge> <DRI_Background agreement="All_Equal">Hence, there are many different ways to create characters using commercial tools.</DRI_Background> <DRI_Background agreement="All_Equal">One technique involves modeling skin substructure such as muscles and tendons to drive the skin geometry [Wilhelms and Gelder 1997; Scheepers et al. 1997].</DRI_Background> <DRI_Background agreement="All_Equal">Many deformers which drive skins by linking their control points to the skeletal parameters with custom expressions or scripts are also available.</DRI_Background> <DRI_Background agreement="All_Equal">Some examples include FFD lattices [Sederberg and Parry 1986] or Wires [Singh and Fiume 1998].</DRI_Background> <DRI_Background agreement="All_Equal">High-end characters often use a combination of these techniques—different tools are appropriate for different parts of the character.</DRI_Background> <DRI_Background agreement="All_Equal">This generality and control means that the computation aspect of high-end characters is highly customizable, tightly coupled to authoring, and potentially unbounded.</DRI_Background> <DRI_Background agreement="All_Equal">In fact, high-end tools allow authors to continually develop new skin computation models through custom scripts, expressions and complex deformers.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">In contrast, interactive systems require fast computation and small memory size for characters.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Thus, the character computation model is fixed and artists must restrict their tool set to author characters in direct support of it.</DRI_Background> <DRI_Background agreement="All_Equal">The most common skin computation model in games and interactive systems goes by many names including SSD, enveloping, smooth skinning, and linear blend skinning.</DRI_Background> <DRI_Background agreement="All_Equal">This technique assigns a set of influencing joints and blending weights to each vertex in the character.</DRI_Background> <DRI_Background agreement="All_Equal">The skin is computed by transforming each vertex by a weighted combination of the joints’ local coordinate frames.</DRI_Background> <DRI_Unspecified agreement="All_Equal">This technique is discussed in more detail in Section 3.</DRI_Unspecified> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">While fast to evaluate and compact in memory, this method is notorious not only for its authoring difficulty, but also for its undesirable deformation artifacts.</DRI_Background> <DRI_Background agreement="All_Equal">However, this method is widely used since these characters can be used with arbitrary amounts of animation data and can be posed at runtime.</DRI_Background> <DRI_Background agreement="All_Equal">A different character computation mechanism previously used in interactive systems is called mesh animation.</DRI_Background> <DRI_Background agreement="All_Equal">Mesh animation works by storing a large number of deformed models as static meshes—one for each frame of animation.</DRI_Background> <DRI_Background agreement="All_Equal">These static models are then either displayed directly or are linearly interpolated at runtime.</DRI_Background> <DRI_Background agreement="All_Equal">Mesh animation is interesting since it decouples skin authoring from runtime skin computation, allowing artists to use any tools they want to author characters.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Unfortunately mesh animation is only appropriate when the required animation sequences are short and are known a priori.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">As games and interactive applications use larger amounts of animation, storing every frame becomes prohibitive.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">This technique is also incapable of generating new poses at runtime; for example, to place the character’s hand exactly on a door knob or to make footfalls land precisely on stairs.</DRI_Background> <DRI_Background agreement="All_Equal">Due to these limitations, mesh animation is losing popularity.</DRI_Background> <DRI_Outcome_Contribution ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome">In this paper, we present an automated method to build character skins that are fast to compute and compactly represented from a set of examples.</DRI_Outcome_Contribution> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">This technique allows artists to use any skin authoring tools they like while producing characters that meet the performance demands and work with the computation models used in interactive systems.</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">We present a framework for extending linear blend skinning that allows us to capture these detailed skin deformations.</DRI_Outcome_Contribution> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">We show how we can fit the parameters of our skinning model using a sampling of an arbitrarily rigged character’s deformations.</DRI_Outcome> <DRI_Unspecified agreement="All_Equal">The rest of this paper is organized as follows.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">After a review of related work, we describe the simple linear blend skinning model and its strengths and weaknesses.</DRI_Unspecified> <DRI_Unspecified ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Approach">The limitations of this approach lead us to a discussion of our framework for extending this skinning model.</DRI_Unspecified> <DRI_Unspecified ann2="DRI_Unspecified" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Approach">Next we describe how we fit the parameters of our skinning model using a sampling of the original character deformations.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">Finally we present results and applications of our technique.</DRI_Unspecified>
      ∗ {amohr, gleicher}@cs.wisc.edu , http://www.cs.wisc.edu/graphics
      ∗
      1
      To appear at SIGGRAPH 2003
      
        <h1>1.1 System Overview</h1>
        <DRI_Approach agreement="All_Equal">Building a skin with our system involves two major steps.</DRI_Approach> <DRI_Approach agreement="All_Equal">We begin with a character rigged in an animation package such as Maya.</DRI_Approach> <DRI_Approach agreement="All_Equal">We then sample this character’s skin deformations by exporting the character’s geometry in several poses.</DRI_Approach> <DRI_Approach agreement="All_Equal">Next we fit the parameters of our underlying skinning model using this sampled data.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge">We wish to obtain a good sampling of the character’s skin deformations to fit our underlying model with.</DRI_Approach> <DRI_Approach agreement="All_Equal">To do this, we pose the character to exercise all the joints fully and include its extreme poses.</DRI_Approach> <DRI_Approach agreement="All_Equal">This step does not require a trained animator since these poses are only intended to exercise the degrees of freedom of the character and need not correspond to a realistic motion.</DRI_Approach> <DRI_Approach agreement="All_Equal">Once this is done, the poses are sampled regularly at k times.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">This sampling can be very simple to obtain from the user’s perspective—in our case, users must simply invoke a script we have implemented in Maya.</DRI_Approach> <DRI_Approach agreement="All_Equal">Each sample consists of the skeleton configuration and the corresponding deformed skin geometry as a static mesh.</DRI_Approach> <DRI_Approach agreement="All_Equal">We call a paired skeleton configuration and static mesh an example.</DRI_Approach> <DRI_Approach agreement="All_Equal">Using this set of examples, our system first determines the set of joints that should influence each vertex, and then solves a bilinear least-squares problem to fit the parameters of the underlying skinning model.</DRI_Approach> <DRI_Approach agreement="All_Equal">As mentioned earlier, the skinning model we use is an extension of the standard linear blend skinning model.</DRI_Approach> <DRI_Approach agreement="All_Equal">Our extension adds extra joints to the character that are simply related to the existing joints.</DRI_Approach> <DRI_Approach agreement="All_Equal">These new joints are designed in such a way to capture richer deformations than the standard linear blend skinning model.</DRI_Approach> <DRI_Approach agreement="All_Equal">Our system is configured to add these extra joints automatically to characters, but we allow users to fine tune the specific set of extra joints if they wish.</DRI_Approach>
      
      
        <h1>2 Related Work</h1>
        <DRI_Background agreement="All_Equal">Character skin deformations are fundamental to character animation and have been addressed for some time in the literature.</DRI_Background> <DRI_Background agreement="All_Equal">Catmull [1972] introduced one of the first skeleton-driven techniques—rigid skinning to a hierarchically structured articulated figure.</DRI_Background> <DRI_Background agreement="All_Equal">A 2D skeletal bilinear deformation method was presented by Burtnyk and Wein [1976].</DRI_Background> <DRI_Background agreement="All_Equal">An early 3D skeleton-driven technique that went beyond rigid skinning was presented by MagnenatThalmann, et al. [1988].</DRI_Background> <DRI_Background agreement="All_Equal">Their technique used custom programmed algorithms to deform character meshes based on the nature of particular joints.</DRI_Background> <DRI_Background agreement="All_Equal">More recently, novel skinning methods that start with a simple skin and use sparse data interpolation to correct errors between it and a set of examples have been introduced.</DRI_Background> <DRI_Background agreement="All_Equal">Three examples, Pose Space Deformation, Shape by Example, and EigenSkin [Lewis et al. 2000; Sloan et al. 2001; Kry et al. 2002] use radial basis interpolation of corrections to linear blend skins.</DRI_Background> <DRI_Background agreement="All_Equal">Another recent work applies these techniques to range scan data [Allen et al. 2002].</DRI_Background> <DRI_Background agreement="All_Equal">These techniques are similar to ours in that they take examples as input.</DRI_Background> <DRI_Background agreement="All_Equal">The results of these approaches are quite good, and unlike our technique, they can handle skin deformations that depend on abstract parameters rather than only skeleton configurations.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">However, these methods are not appropriate for interactive characters since they require storing potentially large amounts of example data for runtime interpolation.</DRI_Background> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">In contrast, our method discards all example data after the fitting process so the size of our runtime structures does not scale with the number of inputs.</DRI_Approach> <DRI_Background agreement="All_Equal">Other authors have used physical simulation for interactive deformations, especially secondary animation [James and Pai 2002; Capell et al. 2002].</DRI_Background> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">Our method cannot capture these secondary deformations directly; however, a technique such as DyRT [James and Pai 2002] can be applied to the characters we generate to add secondary animation.</DRI_Approach> <DRI_Background agreement="All_Equal">There has been some recent work on fitting skinning models.</DRI_Background> <DRI_Background agreement="All_Equal">One method solves for joint centers and vertex weights for a scanned arm [Nebel and Sibiryakov 2002] but the Multi-Weight Enveloping technique [Wang and Phillips 2002], or MWE, is most similar to our approach.</DRI_Background> <DRI_Background agreement="All_Equal">MWE extends linear blend skinning by giving each vertex one weight to each coefficient of each influencing joint’s transformation matrix instead of one weight per influencing joint.</DRI_Background> <DRI_Background agreement="All_Equal">They then find these weights by solving a linear leastsquares problem using a set of examples as input.</DRI_Background> <DRI_Background agreement="All_Equal">While on the surface Multi-Weight Enveloping and our technique seem very similar, they are in fact different in a fundamental way.</DRI_Background> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">Both MWE and our technique use an extension of linear blend skinning as an underlying deformation model.</DRI_Approach> <DRI_Background agreement="All_Equal">However, MWE extends linear blend skinning by adding more vertex weights to the model while in contrast, our method adds more joints.</DRI_Background> <DRI_Background agreement="All_Equal">MWE uses a large number of weights per vertex (12 per influencing joint).</DRI_Background> <DRI_Background agreement="All_Equal">This introduces the possibility of rank deficient matrices in the least-squares solutions [Wang and Phillips 2002], especially since the matrix coefficients are usually highly correlated.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">This can lead to overfitting, which MWE must take measures to avoid.</DRI_Background> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">In contrast, since the number of weights per vertex in one of our skins remains relatively small (1 per influencing joint) and our extra joints are explicitly designed to be very different from existing joints, our technique requires no special provisions to avoid overfitting.</DRI_Approach> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Even so, our method can detect and handle small amounts of overfitting if it occurs as explained in Section 5.2.</DRI_Outcome> <DRI_Approach ann2="DRI_Background" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">Another consequence of having one weight per entry in the joint transformation matrices is that MWE skins are not as easily accelerated by graphics hardware as skins created using our method.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">Finally, since our skins are computed in the same manner as linear blend skins, existing software infrastructure can make use of them with little or no changes.</DRI_Approach>
        2
        To appear at SIGGRAPH 2003
      
      
        <h1>3 Linear Blend Skinning</h1>
        <DRI_Background agreement="All_Equal">The traditional interactive skinning model goes by many names.</DRI_Background> <DRI_Background agreement="All_Equal">Lewis et. al call it Skeleton Subspace Deformation or SSD, Maya calls it “smooth skinning” and we call it linear blend skinning.</DRI_Background> <DRI_Background agreement="All_Equal">This technique is widely used for interactive applications.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Unspecified">An excellent description of this method is found in Lewis et al. [2000].</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">The linear blend skinning algorithm works by first placing a hierarchical skeleton inside a static model of a character, typically in some neutral pose.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">This initial character pose is referred to as “dress pose”.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">Then, each vertex is assigned a set of influencing joints and a blending weight for each influence.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">Computing the deformation in some pose involves rigidly transforming each dress pose vertex by all of its influencing joints.</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">Then the blending weights are used to combine these rigidly transformed positions.</DRI_Background> <Sentence agreement="All_Equal">The deformed vertex position at some skeletal configuration c, v c is computed as</Sentence>
        
          1
          n v c = ∑ w i M i,c M i,d −1 v d i=1
        
        <Sentence agreement="All_Equal">where w i are the weights (usually affine or convex), v d is the dresspose location of some vertex v, M i,c is the transformation matrix associated with the ith joint in configuration c and M i,d −1 is the inverse of the dress-pose matrix associated with the ith influence.</Sentence> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">(Taken together, M i,d −1 v d represents the location of v d in the local coordinate frame of the ith influence.</DRI_Background><DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">) Note that a deformed vertex position in the dress pose configuration c = d is the same as the provided dress pose vertex ( v d = v d ) if the weights are affine.</DRI_Background> <DRI_Background agreement="All_Equal">This skinning algorithm is notorious for its failings.</DRI_Background> <DRI_Background agreement="All_Equal">It cannot represent complex deformations and suffers from characteristic artifacts such as the “candy-wrapper” collapse effect on wrists and collapsing around bending joints as shown in Figure 2 .</DRI_Background> <DRI_Background agreement="All_Equal">The artifacts occur because vertices are transformed by linearly interpolated matrices.</DRI_Background> <DRI_Background agreement="All_Equal">If the interpolated matrices are dissimilar as in a rotation of nearly 180 degrees, the interpolated transformation is degenerate, so the geometry must collapse.</DRI_Background> <DRI_Background agreement="All_Equal">In addition to these deformation problems, linear blend skins are very difficult to author [Lewis et al. 2000].</DRI_Background> <DRI_Background agreement="All_Equal">Despite its failings, this skinning algorithm is very fast and widely supported by commercial applications so it remains popular especially in games and virtual environments.</DRI_Background>
      
      
        <h1>4 Extending Linear Blend Skinning</h1>
        <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">The linear blend skinning model is not sufficient to capture deformations well as shown in Figure 3 .</DRI_Challenge> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">The problem in this particular case is that as the twist approaches 180 degrees, the linearly blended matrix becomes degenerate and collapses the skin geometry.</DRI_Challenge> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Linearly blended transformations tend to collapse the more different they are.</DRI_Challenge> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Outcome">The resulting loss of volume can also be observed around hinge joints such as the knee and elbow as shown in Figure 2 .</DRI_Challenge> <DRI_Challenge_Hypothesis ann2="DRI_Challenge_Hypothesis" agreement="2equal_1diff" ann1="DRI_Challenge_Hypothesis" ann3="DRI_Outcome">We observe that we can help avoid the collapse problem by avoiding blending transformations that are so dissimilar.</DRI_Challenge_Hypothesis> <DRI_Approach ann2="DRI_Challenge_Hypothesis" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">We can accomplish this by adding extra transformations that properly interpolates without collapsing.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">In the case of the twisting wrists, we can add an extra joint that interpolates the rotation angle correctly and does not collapse.</DRI_Approach> <DRI_Background agreement="All_Equal">In fact, artists sometimes do this by hand to help avoid wrist collapses.</DRI_Background> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">More generally, we observe that any deformation effect could be obtained by adding joints that deform appropriately to capture that deformation effect.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">For example, to capture muscle bulges, we can add joints that scale up when the muscle should bulge, and scale down when the muscle relaxes.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">For wrinkles, we could add several joints that move and scale in concert to capture the wrinkles.</DRI_Approach> <Sentence agreement="All_Equal">In</Sentence>
        
          
          Figure 2: Common problems with linear blend skinning: the bent arm on the left demonstrates shrinkage around bent joints such as the elbow and knee while the twisted wrist on the right demonstrates the “candy-wrapper” collapse effect. These artifacts are caused by blending dissimilar transformations.
        
        
          
          Figure 3: Top Row: Three examples of a twisting box driven by a nonlinear de-
        
        <Sentence agreement="All_Equal">former.</Sentence> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="Sentence">Middle Row: Solved linear blend skin using one joint.</Sentence> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="Sentence">Bottom Row: Our result with just one additional joint that half interpolates the twist rotation.</Sentence>
        <Sentence agreement="All_Equal">fact, in the limit we could add as many transformations as vertices and capture all deformations exactly.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge">Unfortunately, adding so many extra joints is impractical.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge">First, adding such a large number of joints would severely impact the performance of our resulting skins.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge">Worse, even if we could find these transformations for the input examples, it is unclear how to determine the general relationships of these transformations to the skeletal parameters in all poses.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Challenge">Without knowledge of this relationship, our scheme would only be able to reproduce the input frames and would not work well in new poses.</DRI_Approach> <DRI_Approach agreement="All_Equal">Instead, we extend the traditional linear blend skinning model by adding a relatively small number of joints that are simply related to the original skeletal parameters and fit using them.</DRI_Approach> <DRI_Approach agreement="All_Equal">We choose these extra joints by both examining the places where the standard linear blend model fails and by examining extra character deformations that we would like to capture.</DRI_Approach> <DRI_Approach agreement="All_Equal">We then add joints that we believe will help resolve these artifacts.</DRI_Approach> <DRI_Approach agreement="All_Equal">Finally, we fit the parameters of our skinning model using this extended skeleton.</DRI_Approach> <DRI_Approach agreement="All_Equal">The key to our success is that since vertices choose weighted sums of transformations, if any linear scaling of an added joint is beneficial it may be used.</DRI_Approach> <DRI_Approach agreement="All_Equal">Thus the additional joints need not be exact.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Challenge_Goal" ann3="DRI_Approach">We emphasize that this is a framework for obtaining better deformations and the joints we choose to add are based on our observations of characters.</DRI_Approach> <DRI_Approach agreement="All_Equal">Different characters with different deformations may require a different set of additional joints.</DRI_Approach> <DRI_Approach agreement="All_Equal">However, once some set of these joints is determined, the skin may be solved using our fitting algorithm without change.</DRI_Approach>
        3
        To appear at SIGGRAPH 2003
        
          
        
        blend skin approximation. Bottom Row: Our result using one additional joint.
        
          Figure 4: Top Row: Original examples of a twisting wrist. Middle Row: Linear
          
        
        
          Figure 5: Linear blend skinning alone is incapable of capturing correct creasing
        
        <Sentence agreement="All_Equal">around elbows.</Sentence> <DRI_Unspecified agreement="All_Equal">At the left is an example of a bent elbow.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">In the middle is the linear blend skin approximation.</DRI_Unspecified> <DRI_Unspecified ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">notice the interpenetration.</DRI_Unspecified> <DRI_Unspecified ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">In contrast, our method avoids the interpenetration.</DRI_Unspecified>
      
      
        <h1>4.1 Additional Joints</h1>
        <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">To help solve the collapsing geometry problem, our system can automatically add joints that properly interpolate rotations without collapsing.</DRI_Outcome> <DRI_Approach agreement="All_Equal">This is done by examining the rotation of a joint relative to the dress pose and computing the new joint as the halfway spherical linear interpolation [Shoemake 1985] of this rotation, located at the same position in space.</DRI_Approach> <DRI_Approach agreement="All_Equal">More joints with evenly distributed interpolation parameters could be added to sample this rotation space even better; however, in our experience just a single interpolated rotation is sufficient.</DRI_Approach> <DRI_Unspecified ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">Figure 4 demonstrates the improvements gained by simply adding a single interpolated rotation joint in the twisting case.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">Figure 5 shows the improvements for the bent elbow case.</DRI_Unspecified> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Another type of effect not easily captured by the simple linear blend model is bulging and denting of skins caused by muscles, tendons, or other substructure.</DRI_Challenge> <DRI_Challenge ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">These particular effects cannot be captured since the joints employed in animating a character do not typically scale up and down as would be necessary to approximate these effects.</DRI_Challenge> <DRI_Approach ann2="DRI_Challenge" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">We have observed that for many characters, the substructure deformation effects from muscles and tendons are often simply related to the angles between joints.</DRI_Approach> <DRI_Approach ann2="DRI_Challenge" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">For example, a bicep bulge is small when the elbow is near full extension while the bugle is large when the elbow is near full flexion.</DRI_Approach> <DRI_Approach ann2="DRI_Challenge" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">The effect is similar for other muscles in the body.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">To capture these effects, our system can add several joints that scale up and down based on the angle between particular joints.</DRI_Approach> <DRI_Approach agreement="All_Equal">We add these scaling joints as follows.</DRI_Approach> <DRI_Approach agreement="All_Equal">First we choose a joint in the original skeleton that will drive the scaling parameters of the new joints.</DRI_Approach> <DRI_Approach agreement="All_Equal">Once this driver is chosen, there are two sets of joints that we add.</DRI_Approach> <DRI_Approach agreement="All_Equal">The first set is “upstream” of the driver and lies in the middle of the bone connecting the driver to its parent, the second set is “downstream” and lies in the middle of the bones connecting the driver to its children.</DRI_Approach> <DRI_Approach agreement="All_Equal">All upstream joints are oriented in the same way, with one axis aligned with the bone as shown in Figure 6 .</DRI_Approach> <DRI_Approach agreement="All_Equal">We use four upstream joints.</DRI_Approach> <DRI_Approach agreement="All_Equal">Two of them scale up about two axes orthogonal to the bone and a corresponding pair scale down about the two axes orthogonal to the bone.</DRI_Approach> <DRI_Approach agreement="All_Equal">The scale parameters of these joints are set based on the angle of the bone connecting the driver to its parent and the bone connecting the driver to its child.</DRI_Approach> <DRI_Approach agreement="All_Equal">If the driver has multiple children, a vector that is the sum of the bones connecting the driver to its children is used to measure the angle.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">Downstream joints are similar.</DRI_Approach> <DRI_Approach agreement="All_Equal">We use four downstream joints on each bone connecting the driver to its children that scale just as the upstream joints do.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">The scale parameters are computed as follows.</DRI_Approach> <DRI_Approach agreement="All_Equal">For joints that scale up, the scale parameter s is s = 1 + k b 1 · b 2 + 1 2 b 1 b 2 where b 1 and b 2 are the bone vectors used to measure the angle at the driver joint and k is the maximum scale factor when the angle between b 1 and b 2 is zero.</DRI_Approach> <DRI_Approach agreement="All_Equal">For joints that scale down, the scale parameter is simply s −1 .</DRI_Approach> <DRI_Approach agreement="All_Equal">The value for k may be chosen by the user but in our experience, we have found that 8 works well for our examples.</DRI_Approach> <DRI_Approach agreement="All_Equal">Again, since vertices may take any scaling of these new joints, a conservative large value is fine.</DRI_Approach> <DRI_Approach agreement="All_Equal">For example, if a vertex in fact needed a joint that scaled by 2 instead of 8, it could be assigned a weight of 4 1 .</DRI_Approach>
        J1 v1 θ v2 J3 J4-J7 J2 Driver
        
          Figure 6: Our method adds extra joints to characters to help better approximate deformations. Here J4 through J7 are automatically added upstream joints that scale depending on the angle θ. As θ decreases, J4 scales up in the direction v1 which is orthogonal to the bone connecting J1 and J2. Meanwhile, J5 scales up in the direction v2, orthogonal to both the bone and v1. J6 and J7 operate similarly, but scale down as θ increases rather than up. Downstream joints are very similar except that these joints are positioned on the bone from J2 to J3.
        
      
      
        <h1>5 Fitting the Skinning Model</h1>
        <DRI_Approach agreement="All_Equal">Once our system has augmented the input skeleton, we use a fitting procedure to set the parameters of the underlying skinning model to match the example data well.</DRI_Approach> <DRI_Approach agreement="All_Equal">As mentioned earlier, the input to the fitting process is a set of examples.</DRI_Approach> <DRI_Approach agreement="All_Equal">An example is simply a static character mesh paired with a skeleton.</DRI_Approach> <DRI_Approach agreement="All_Equal">This static mesh is deformed according to the skeleton configuration, but it is not attached to the skeleton in any way.</DRI_Approach> <DRI_Approach agreement="All_Equal">For our results, our examples were generated by exporting rigged objects from Maya, but they could have been sculpted by hand or come from another program.</DRI_Approach> <DRI_Approach agreement="All_Equal">A linear blend skin computes a deformed vertex as described earlier in Equation 1.</DRI_Approach> <DRI_Approach agreement="All_Equal">Examining this skinning model, only the M i are predetermined.</DRI_Approach> <DRI_Approach agreement="All_Equal">These are the coordinate frames associated with all the joints in the character.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">That means for each vertex, we are able to choose the set of influencing joints, influence weights (w i ) and the dress pose vertex position (v d ).</DRI_Approach> <DRI_Approach agreement="All_Equal">We would like to choose the influence sets, weights and dress pose vertex positions that best approximate the examples and generalize well to new poses.</DRI_Approach>
        4
        To appear at SIGGRAPH 2003
        Examples Compactness of Local Coordinate Point Clouds Upper Arm Lower Arm
        
          Figure 7: Top: A set of three examples of a deforming arm mesh with a bulging
        
        <Sentence agreement="All_Equal">bicep.</Sentence> <DRI_Unspecified agreement="All_Equal">A particular point on the arm mesh is highlighted in each example.</DRI_Unspecified> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="Sentence">Bottom Left: Each example rotated and aligned so that the upper arm bones coincide.</Sentence> <DRI_Unspecified ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">The highlighted points form a cloud in the local coordinate frame of the upper arm.</DRI_Unspecified> <DRI_Unspecified ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">Even though the bicep bulges significantly, this cloud is compact.</DRI_Unspecified> <Sentence ann2="Sentence" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="Sentence">Lower Right: A similar point cloud but relative to the forearm.</Sentence> <DRI_Unspecified ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">This cloud is far less compact than the former, making the forearm a poorer choice for an influence.</DRI_Unspecified>
      
      
        <h1>5.1 Finding Influence Sets</h1>
        <DRI_Approach agreement="All_Equal">We determine influence sets first for several reasons.</DRI_Approach> <DRI_Approach agreement="All_Equal">Ideally, the influence sets would fall out naturally from the weight solving procedure (irrelevant joints would have a weight of zero) but this does not happen in practice because our samplings are necessarily not exhaustive.</DRI_Approach> <DRI_Approach agreement="All_Equal">Also, the more joints that a vertex depends on, the slower the skin can be to compute and current hardware only supports a limited number of influences per vertex.</DRI_Approach> <DRI_Approach agreement="All_Equal">Thus, we would like to select a small set of good influences.</DRI_Approach> <DRI_Approach agreement="All_Equal">Also, choosing the influence sets appropriately lets us bound the size of the problems we must solve to determine the weights as discussed in Section 5.2.</DRI_Approach> <DRI_Approach agreement="All_Equal">This makes the solving process faster.</DRI_Approach> <DRI_Background agreement="All_Equal">In most recent research, influence set determination has been left to users [Lewis et al. 2000; Wang and Phillips 2002; Sloan et al. 2001].</DRI_Background> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">The task is typically accomplished by “painting” the regions of influence for each joint over the mesh.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">While less difficult than painting the weights themselves [Lewis et al. 2000], it is a tedious process.</DRI_Background> <DRI_Approach agreement="All_Equal">In contrast, our system automatically determines the influence sets for each vertex using a heuristic algorithm.</DRI_Approach> <DRI_Approach ann2="DRI_Background" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">We observe that vertices in a character skin typically transform nearly rigidly with respect to some joint.</DRI_Approach> <DRI_Approach ann2="DRI_Background" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">For instance, vertices on the forearm roughly follow the forearm.</DRI_Approach> <DRI_Approach ann2="DRI_Challenge_Hypothesis" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">We believe that for most characters, their skin is most heavily influenced by those joints that they are bound to.</DRI_Approach> <DRI_Approach ann2="DRI_Challenge_Hypothesis" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">Even though a point on the bicep is not truly rigid as an arm moves (due to muscle bulge), we believe that these points remain mostly rigidly attached to the upper arm, and therefore should be influenced by it.</DRI_Approach> <DRI_Approach agreement="All_Equal">Using this observation, we measure how rigidly a vertex transforms with every joint over all examples and use the most rigidly transforming joints for the influence set.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Unspecified">For a single vertex, a rigidity score for a joint is computed as follows.</DRI_Approach> <DRI_Approach agreement="All_Equal">For each example, the local coordinate position of the vertex is computed as M i,e −1 v e where M i,e is the coordinate frame associated with the ith joint in the eth example and v e is the global coordinate position of the vertex on the eth example.</DRI_Approach> <DRI_Approach agreement="All_Equal">The collection of these local coordinate positions over all examples forms a point cloud as shown in Figure 7 .</DRI_Approach> <DRI_Approach agreement="All_Equal">The more compact this point cloud, the more rigid we believe the vertex-joint relationship to be.</DRI_Approach> <DRI_Approach agreement="All_Equal">We measure the compactness of this point cloud by taking its diameter (the maximum distance between any two points in the cloud).</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">We have found that the simple O(n 2 ) algorithm that compares each point to every other to be fast enough for our purposes but this diameter may be computed more quickly.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">An O(n log n) time algorithm is possible.</DRI_Approach> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Unspecified">See [Malandain and Boissonnat 2002] for faster methods.</DRI_Background> <DRI_Approach ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Approach">Once the compactness measures for all joints are computed for a vertex, the smallest k are chosen as the influence set for that vertex.</DRI_Approach> <DRI_Approach agreement="All_Equal">It may be tempting to use a threshold scheme to choose influence sets but we have found this problematic.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">It is unclear how to pick a good threshold because as the rigidity scores get larger, they become less meaningful.</DRI_Approach> <DRI_Approach ann2="DRI_Challenge" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">For instance, it may happen as an artifact of the particular input examples that points on the left shoulder move much more rigidly relative to the right leg rather than the left leg but both choices make no sense for influences.</DRI_Approach> <DRI_Approach ann2="DRI_Challenge" agreement="3diff" ann1="DRI_Approach" ann3="DRI_Outcome">Since larger rigidity scores are not particularly meaningful, it is nearly impossible to pick a meaningful threshold value.</DRI_Approach> <DRI_Approach agreement="All_Equal">As in other linear blend skinning systems, influence sets need only be determined conservatively [Wang and Phillips 2002] so we allow users to choose k if desired.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">In our experience, we have found that between three and eight influences works well, depending on the complexity of the character.</DRI_Approach>
      
      
        <h1>5.2 Solving for Weights and Vertices</h1>
        <DRI_Approach agreement="All_Equal">Once the influence sets have been determined, only the weights and dress pose vertex positions remain (w i and v d ).</DRI_Approach> <DRI_Approach agreement="All_Equal">We would like to find the best vertices and weights that minimize the least-squares difference between the skin and the examples at all the example skeleton configurations.</DRI_Approach> <DRI_Approach agreement="All_Equal">That is
        n 2 min ∑ v e i − v e i i=1
        for all examples where v e i is the input vertex position from the ith example and v e i is the deformed vertex computed by the skinning model at the ith example configuration.</DRI_Approach> <Sentence agreement="All_Equal">n v e = ∑ w i M i,e M i,d −1 v d i=1 This problem is bilinear in the weights and vertices.</Sentence> <DRI_Approach agreement="All_Equal">We use an alternation technique to solve the optimization.</DRI_Approach> <DRI_Approach agreement="All_Equal">This works by first fixing the first variable and solving a linear least-squares problem to find the second, then fixing the second and solving a linear leastsquares problem for the first.</DRI_Approach> <DRI_Approach agreement="All_Equal">This process is then repeated until it converges.</DRI_Approach> <DRI_Background agreement="All_Equal">This technique is commonly used and is described in [Freeman and Tenenbaum 1997].</DRI_Background> <DRI_Approach agreement="All_Equal">We start by solving for weights since we have no good guess for them but we know that the initial dress pose vertices are ideal.</DRI_Approach> <DRI_Approach agreement="All_Equal">Next we hold the weights fixed and solve for vertex positions.</DRI_Approach> <DRI_Approach agreement="All_Equal">This process typically converges after one or two iterations.</DRI_Approach> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">As mentioned in Section 2, we have found that since we are solving for a small numbers of weights using large numbers of examples, our systems are often well conditioned and do not suffer from overfitting if the input data is well sampled.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Thus we do not have to take special precautions to avoid overfitting as in [Wang and Phillips 2002], although we include tests for robustness.</DRI_Outcome> <DRI_Approach agreement="All_Equal">For clarity, we present the matrices we solve via least-squares in block form.</DRI_Approach> <DRI_Approach agreement="All_Equal">First we introduce some notation: T i,e = M i,e M i,d −1 .</DRI_Approach> <DRI_Approach agreement="All_Equal">In order to ensure that the resulting weights are affine, we set w 1 = 1 − ∑ i=2 n w i , and solve for w 2 through w n .</DRI_Approach>
        <Sentence agreement="All_Equal">   (T (T 2,e 2,e 1 k − − .</Sentence> . . <Sentence agreement="All_Equal">T T 1,e 1,e k 1 )v )v d d ··· ··· ..</Sentence> . <Sentence agreement="All_Equal">(T (T n,e n,e 1 k − − .</Sentence> . . <Sentence agreement="All_Equal">T T 1,e 1,e k 1 )v )v d d        w w w .</Sentence> . . <Sentence agreement="All_Equal">2 n 3     =    v v e e 1 k − − T T .</Sentence> . . <Sentence agreement="All_Equal">1,e 1,e 1 k v v d d</Sentence>
          
        5
        To appear at SIGGRAPH 2003
        The matrix used to solve for vertex positions is as follows. <Sentence agreement="All_Equal">   ∑ ∑ i=1 n i=1 n w w . . . i i T T i,e i,e 1 k    v d =    v v . . . e e 1 k    To handle homogeneous coordinates, the translation parts of the ∑ i=1 n w i T i,e k matrices are subtracted from the v e on the right hand side.</Sentence> <DRI_Approach agreement="All_Equal">We solve these least-squares problems using the singular value decomposition.</DRI_Approach> <DRI_Approach agreement="All_Equal">This lets us detect when our matrices are rank deficient, leading to overfitting.</DRI_Approach> <DRI_Approach agreement="All_Equal">We detect this by comparing the ratio of the largest singular value to the smallest, and issuing a warning if there are any singular values below some fraction of this ratio.</DRI_Approach> <DRI_Approach agreement="All_Equal">To recover, we zero these singular values and continue with the fitting process.</DRI_Approach> <DRI_Approach agreement="All_Equal">If overfitting is a problem, provisions such as those taken in [Wang and Phillips 2002] could also be used.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Outcome">However, in all the examples in this paper, no singular values were zeroed.</DRI_Approach>
      
      
        <h1>5.3 Handling Normals</h1>
        <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">It is not only important for the geometry in a skin approximation to be accurate, but also important for normals to be well approximated.</DRI_Approach> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Approach" ann3="DRI_Background">If they are not, lighting calculations will not produce good results.</DRI_Approach> <DRI_Approach agreement="All_Equal">We assume that normals are specified per vertex.</DRI_Approach> <DRI_Approach agreement="All_Equal">It may seem that just transforming a dress pose normal by the inverse transpose of the corresponding vertex’s transformation matrix would be correct.</DRI_Approach> <Sentence agreement="All_Equal">To be more explicit, n  ̄ c = ( ∑ w i M i,c M i,d −1 ) −T n d ( ∑ w i M i,c M i,d −1 ) −T n d While this is technically valid for local neighborhoods of smooth surfaces [Turkowski 1990], we do not have a smooth surface.</Sentence> <DRI_Approach agreement="All_Equal">Instead we have single points that are computed independently.</DRI_Approach> <DRI_Approach agreement="All_Equal">Computing the normals in this manner can give undesirable results when the blended transformations are not pure rotations.</DRI_Approach> <Sentence agreement="All_Equal">Interactive systems typically approximate normal calculations as</Sentence>
        
          2
          n  ̄ c = ∑ w i M i,c −T M i,d T n d ∑ w i M i,c −T M i,d T n d
        
        <Sentence agreement="All_Equal">since it is often faster to calculate the joint matrices and their inverses incrementally by composition because at each step, rotations and scales have special inverse forms.</Sentence> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Approach">This alleviates the need for a general inversion operation.</DRI_Approach> <DRI_Background agreement="All_Equal">In EigenSkin [Kry et al. 2002], normals are treated as second skinning problem and are computed independently.</DRI_Background> <DRI_Approach agreement="All_Equal">In our system, we take the model used in existing systems as in Equation 2 and include normals in our optimization process.</DRI_Approach> <DRI_Approach agreement="All_Equal">To do this, we simply add more terms to the objective function to include the differences between normal vectors.</DRI_Approach> <DRI_Approach agreement="All_Equal">We allow users to scale normals if they wish to change their relative influence on the least-squares solution.</DRI_Approach>
      
      
        <h1>6 Results</h1>
        <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">The simple linear blend skinning model commonly used in video games and other interactive applications is very fast and compact but cannot capture the high quality deformations that make convincing characters.</DRI_Challenge> <DRI_Outcome_Contribution ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">Our framework for extending the linear blend model allows us to capture much more interesting deformations while retaining its efficiency.</DRI_Outcome_Contribution> <DRI_Outcome_Contribution ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">The most egregious deformation problems of linear blend skinning are solved by our approach.</DRI_Outcome_Contribution> <DRI_Unspecified ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">Figures 3 and 4 show how our system can fix collapsing twists by adding just a single extra joint.</DRI_Unspecified> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Collapsing and interpenetrations around hinge joints are also fixed using our method as shown in Figure 5 .</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Approach" agreement="3diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome">In addition to solving these problems with linear blend skinning, our extension framework can capture other more subtle and detailed deformations required for convincing characters.</DRI_Outcome_Contribution> <DRI_Unspecified ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Unspecified">Figure 8 demonstrates how our method can capture the bulges in the biceps and triceps of a character’s arm.</DRI_Unspecified> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">While the particular extra joints we have chosen to add to our characters may not be capable of capturing the full deformation for any character, different extra joints that do capture the desired deformations may be added and solved using our technique.</DRI_Outcome> <DRI_Approach ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Unspecified" ann3="DRI_Approach">To demonstrate that our technique can be used on more than just simple arms and legs, Figure 9 shows a rigged upper body and its approximation by our system.</DRI_Approach> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">This figure also shows this character in new poses from an animation sequence, demonstrating that our resulting skins generalize well to new poses.</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Approach" agreement="3diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome">Our solution procedure is generally very fast.</DRI_Outcome_Contribution> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">None of the examples shown here took more than five minutes to solve on a modern personal computer.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">The slowest was the upper body model which has more than 6000 vertices, 50 examples, and 5 influences per vertex.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">The computation time for each vertex depends on the number of influences and the number of examples.</DRI_Outcome> <DRI_Outcome ann2="DRI_Approach" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Also, since each vertex is solved independently, our algorithm is trivial to parallelize.</DRI_Outcome>
        
          
          Figure 8: Top: Examples of a muscular arm flexing. Middle: Linear blend skin approximation. Note the lack of bicep bulge. Bottom: Results using our method.
        
      
      
        <h1>6.1 Applications</h1>
        <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Outcome">The ability to generate compactly represented, fast to evaluate, high quality skin approximations from a set of examples is very useful.</DRI_Outcome> <DRI_Challenge ann2="DRI_Outcome" agreement="3diff" ann1="DRI_Challenge" ann3="DRI_FutureWork">Applications range from building characters for video games and virtual environments to high-end animation previewing.</DRI_Challenge> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Background">Many current interactive systems such as video games only support linear blend skinned characters.</DRI_Background> <DRI_Challenge agreement="All_Equal">Aside from the deformation problems associated with using this model, authoring these skins is notoriously difficult.</DRI_Challenge> <DRI_Challenge agreement="All_Equal">Determining the blending weights and influence sets is left to the skin author to set directly.</DRI_Challenge> <DRI_Challenge ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Challenge" ann3="DRI_Challenge">None of the more intuitive or useful deformer primitives provided by animation systems may be used.</DRI_Challenge> <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">Using our method, character authors may use any tools they like to author characters.</DRI_Outcome_Contribution> <DRI_Outcome agreement="All_Equal">All our system requires is a set of examples which is used to compute the appropriate influence sets and blending weights automatically.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">This frees the author from setting them manually.</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">It is important to note that since our characters are a straightforward extension to linear blend skinning, many existing interactive systems already have the software infrastructure to sup- port them.</DRI_Outcome_Contribution> <DRI_Outcome agreement="All_Equal">In addition, since our skins are computed in the same manner as existing linear blend skins, they are already accelerated by current graphics hardware.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_FutureWork">Another application of our system is to map a character originally attached to one skeleton onto a different underlying skeleton.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">We call this process skin retargeting.</DRI_Outcome> <DRI_Outcome ann2="DRI_Background" agreement="3diff" ann1="DRI_Outcome" ann3="DRI_Approach">Skin retargeting is useful if a particular interactive system requires characters to have a specific skeleton.</DRI_Outcome> <DRI_Outcome ann2="DRI_Background" agreement="3diff" ann1="DRI_Outcome" ann3="DRI_Approach">For instance, a video game may have an optimized engine for characters with a particular skeleton topology.</DRI_Outcome> <DRI_Outcome ann2="DRI_Background" agreement="3diff" ann1="DRI_Outcome" ann3="DRI_Challenge">Ordinarily, if a character was created for a different skeleton, the character would have to be re-rigged manually to work on the new skeleton topology.</DRI_Outcome> <DRI_Outcome agreement="All_Equal">However, this can be accomplished much more easily with our system.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">One just exports a set of example meshes deformed by the original skeleton but paired with corresponding poses of the new skeleton.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Approach">Our system sees this as any other set of data and solves for the proper influence sets and blending weights.</DRI_Outcome> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_FutureWork">Another application of our technique is targeted at high-end animation.</DRI_Outcome> <DRI_Background ann2="DRI_Background" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Challenge">High-end characters often have such complex deformations that they cannot be computed interactively.</DRI_Background> <DRI_Background ann2="DRI_Challenge" agreement="2equal_1diff" ann1="DRI_Background" ann3="DRI_Background">Thus, animators typically work with low fidelity versions that only roughly suggest the actual shape of the character.</DRI_Background> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome_Contribution">Using our method, interactive characters could be built that allow animators to interact with much better approximations of the deformed characters.</DRI_Outcome>
        6
        To appear at SIGGRAPH 2003
        
          
          
          
          Figure 9: Top Row: Examples of an upper body rigged in Maya. Middle Row: Best linear blend skin. Note the circled problem areas. Bottom Row: Our results.
        
      
      
        <h1>6.2 Discussion</h1>
        <DRI_Outcome_Contribution ann2="DRI_Outcome_Contribution" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Unspecified">In this paper, we have presented a method for building fast to evaluate, compact representations that produce accurate approximations of deforming characters.</DRI_Outcome_Contribution> <DRI_Outcome ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome">The characters may be rigged using any available tool since our system only requires static deformed meshes paired with skeletal configurations as input.</DRI_Outcome> <DRI_Outcome ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">While our technique works well for a wide variety of character skins, it has limitations.</DRI_Outcome> <DRI_Outcome ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">For instance, character deformations in our model are only driven by the skeleton’s joint parameters.</DRI_Outcome> <DRI_Outcome ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Our method cannot capture deformations that are driven by abstract parameters such as “happiness” as in [Lewis et al. 2000; Sloan et al. 2001].</DRI_Outcome> <DRI_Outcome ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Our system also cannot accurately reproduce deformations that are not representable as linear combinations of the transformations expressed in our skeletons.</DRI_Outcome> <DRI_Outcome ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">For instance, the scaling joints presented in this paper can only fully capture deformations that are well approximated by a scaling that is linearly related to the cosine of the angle between two bones.</DRI_Outcome> <DRI_Outcome ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">This assumption may be violated by a character whose muscle bulges only when its arm is fully bent.</DRI_Outcome> <DRI_Outcome ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">The scaling joints also assume that only the angle between joints is important, so bending the shoulder forward is treated the same as bending it up.</DRI_Outcome> <DRI_Outcome ann2="DRI_FutureWork" agreement="2equal_1diff" ann1="DRI_Outcome" ann3="DRI_Outcome">Even though not all deformations can be captured using the extra joints presented here, new joints may be added to capture any important deformation, and our influence set and vertex weight solving framework may be applied without change.</DRI_Outcome> <DRI_Outcome_Contribution ann2="DRI_Outcome" agreement="2equal_1diff" ann1="DRI_Outcome_Contribution" ann3="DRI_Outcome_Contribution">Despite these limitations, our method produces high-quality yet fast and compact skinned characters that work with existing game engines, graphics hardware and other runtime systems.</DRI_Outcome_Contribution>
      
      
        <h1>Acknowledgments</h1>
        <DRI_Unspecified agreement="All_Equal">We would like to thank Luke Tokheim for help with rigging and J. P. Lewis and Karan Singh for their generosity with characters.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">We would also like to thank the UW Graphics Group, especially Andrew Selle and Hyun Joon Shin for their help with video production.</DRI_Unspecified> <DRI_Unspecified agreement="All_Equal">This research is supported by NSF grants CCR-9984506 and CCR-0204372, and equipment donations from Intel.</DRI_Unspecified>
      
      
        <h1>References</h1>
        
          A LLEN , B., C URLESS , B., AND P OPOVI Ć , Z. 2002. Articulated body deformation from range scan data. ACM Transactions on Graphics 21, 3 (July), 612–619.
          B URTNYK , N., AND W EIN , M. 1976. Interactive skeleton techniques for enhancing motion dynamics in key frame animation. CACM 19, 10, 564–569.
          C APELL , S., G REEN , S., C URLESS , B., D UCHAMP , T., AND P OPOVI Ć , Z. 2002. Interactive skeleton-driven dynamic deformations. ACM Transactions on Graphics 21, 3, 586–593.
          C ATMULL , E. E. 1972. A system for computer generated movies. In Proc. ACM Annual Conf. August, 422–431.
          F REEMAN , W. T., AND T ENENBAUM , J. B. 1997. Learning bilinear models for two-factor problems in vision. In IEEE Computer Vision and Pattern Recognition.
          J AMES , D. L., AND P AI , D. K. 2002. DyRT: Dynamic response textures for real time deformation simulation with graphics hardware. ACM Transactions on Graphics 21, 3, 582–585.
          K RY , P. G., J AMES , D. L., AND P AI , D. K. 2002. Eigenskin: Real time large deformation character skinning in hardware. In ACM SIGGRAPH Symposium on Computer Animation, 153–160.
          L EWIS , J. P., C ORDNER , M., AND F ONG , N. 2000. Pose space deformations: A unified approach to shape interpolation and skeleton-driven deformation. In Proceedings of ACM SIGGRAPH 2000, Annual Conference Series, ACM SIGGRAPH.
          M AGNENAT -T HALMANN , N., L APERRIRE , R., AND T HALMANN , D. 1988. Jointdependent local deformations for hand animation and object grasping. In Proceedings of Graphics Interface ’88, 26–33.
          M ALANDAIN , G., AND B OISSONNAT , J.-D. 2002. Computing the diameter of a point set. In Discrete Geometry for Computer Imagery (DGCI 2002), A. Braquelaire, J.O. Lachaud, and A. Vialard, Eds., vol. 2301.
          N EBEL , J.-C., AND S IBIRYAKOV , A. 2002. Range flow from stereo-temporal matching: application to skinning. In IASTED International Conference on Visualization, Imaging, and Image Processing.
          S CHEEPERS , F., P ARENT , R. E., C ARLSON , W. E., AND M AY , S. F. 1997. Anatomybased modeling of the human musculature. In Proceedings of SIGGRAPH 97, Annual Conference Series, ACM SIGGRAPH, 163–172.
          S EDERBERG , T. W., AND P ARRY , S. R. 1986. Free-form deformation of solid geometric models. In Proceedings of SIGGRAPH 86, Annual Conference Series, ACM SIGGRAPH, 151–160.
          S HOEMAKE , K. 1985. Animating rotation with quaternion curves. In Proceedings of SIGGRAPH 85, Annual Conference Series, ACM SIGGRAPH, 245–254.
          S INGH , K., AND F IUME , E. L. 1998. Wires: A geometric deformation technique. In Proceedings of SIGGRAPH 98, Annual Conference Series, ACM SIGGRAPH, 405–414.
          S LOAN , P.-P. J., C HARLES F. R OSE , I., AND C OHEN , M. F. 2001. Shape by example. In Proceedings of the 2001 symposium on Interactive 3D graphics, 135–143.
          T URKOWSKI , K. 1990. Transformations of surface normal vectors. Tech. Rep. 22, Apple Computer, July.
          W ANG , X. C., AND P HILLIPS , C. 2002. Multi-weight enveloping: Least-squares approximation techniques for skin animation. In ACM SIGGRAPH Symposium on Computer Animation, 129–138.
          W ILHELMS , J., AND G ELDER , A. V. 1997. Anatomically based modeling. In Proceedings of SIGGRAPH 97, Annual Conference Series, ACM SIGGRAPH, 173– 180.
        
        7
      
    
  
</Document>